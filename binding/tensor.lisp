(declaim (optimize (speed 3) (debug 1) (safety 0)))

(in-package :th)

#+ccl
(defmethod ccl:terminate ((x tensor.byte))
  (when (has-valid-handle-p x)
    (th-byte-tensor-free ($handle x))
    (reset-handle x)))
#+ccl
(defmethod ccl:terminate ((x tensor.char))
  (when (has-valid-handle-p x)
    (th-char-tensor-free ($handle x))
    (reset-handle x)))
#+ccl
(defmethod ccl:terminate ((x tensor.short))
  (when (has-valid-handle-p x)
    (th-short-tensor-free ($handle x))
    (reset-handle x)))
#+ccl
(defmethod ccl:terminate ((x tensor.int))
  (when (has-valid-handle-p x)
    (th-int-tensor-free ($handle x))
    (reset-handle x)))
#+ccl
(defmethod ccl:terminate ((x tensor.long))
  (when (has-valid-handle-p x)
    (th-long-tensor-free ($handle x))
    (reset-handle x)))
#+ccl
(defmethod ccl:terminate ((x tensor.float))
  (when (has-valid-handle-p x)
    (th-float-tensor-free ($handle x))
    (reset-handle x)))
#+ccl
(defmethod ccl:terminate ((x tensor.double))
  (when (has-valid-handle-p x)
    (th-double-tensor-free ($handle x))
    (reset-handle x)))

(defmethod allocate-tensor ((tensor tensor.byte) &optional dimensions)
  (let ((handle (if dimensions
                    (th-byte-tensor-new-with-size ($handle (storage.long dimensions)) +nil+)
                    (th-byte-tensor-new))))
    (setf ($handle tensor) handle)
    #+sbcl (sb-ext:finalize tensor (lambda () (th-byte-tensor-free handle)))
    #+ccl (ccl:terminate-when-unreachable tensor)))
(defmethod allocate-tensor ((tensor tensor.char) &optional dimensions)
  (let ((handle (if dimensions
                    (th-char-tensor-new-with-size ($handle (storage.long dimensions)) +nil+)
                    (th-char-tensor-new))))
    (setf ($handle tensor) handle)
    #+sbcl (sb-ext:finalize tensor (lambda () (th-char-tensor-free handle)))
    #+ccl (ccl:terminate-when-unreachable tensor)))
(defmethod allocate-tensor ((tensor tensor.short) &optional dimensions)
  (let ((handle (if dimensions
                    (th-short-tensor-new-with-size ($handle (storage.long dimensions)) +nil+)
                    (th-short-tensor-new))))
    (setf ($handle tensor) handle)
    #+sbcl (sb-ext:finalize tensor (lambda () (th-short-tensor-free handle)))
    #+ccl (ccl:terminate-when-unreachable tensor)))
(defmethod allocate-tensor ((tensor tensor.int) &optional dimensions)
  (let ((handle (if dimensions
                    (th-int-tensor-new-with-size ($handle (storage.long dimensions)) +nil+)
                    (th-int-tensor-new))))
    (setf ($handle tensor) handle)
    #+sbcl (sb-ext:finalize tensor (lambda () (th-int-tensor-free handle)))
    #+ccl (ccl:terminate-when-unreachable tensor)))
(defmethod allocate-tensor ((tensor tensor.long) &optional dimensions)
  (let ((handle (if dimensions
                    (th-long-tensor-new-with-size ($handle (storage.long dimensions)) +nil+)
                    (th-long-tensor-new))))
    (setf ($handle tensor) handle)
    #+sbcl (sb-ext:finalize tensor (lambda () (th-long-tensor-free handle)))
    #+ccl (ccl:terminate-when-unreachable tensor)))
(defmethod allocate-tensor ((tensor tensor.float) &optional dimensions)
  (let ((handle (if dimensions
                    (th-float-tensor-new-with-size ($handle (storage.long dimensions)) +nil+)
                    (th-float-tensor-new))))
    (setf ($handle tensor) handle)
    #+sbcl (sb-ext:finalize tensor (lambda () (th-float-tensor-free handle)))
    #+ccl (ccl:terminate-when-unreachable tensor)))
(defmethod allocate-tensor ((tensor tensor.double) &optional dimensions)
  (let ((handle (if dimensions
                    (th-double-tensor-new-with-size ($handle (storage.long dimensions)) +nil+)
                    (th-double-tensor-new))))
    (setf ($handle tensor) handle)
    #+sbcl (sb-ext:finalize tensor (lambda () (th-double-tensor-free handle)))
    #+ccl (ccl:terminate-when-unreachable tensor)))

(defmethod $empty ((tensor tensor)) (make-tensor (type-of tensor)))

(defun print-1d-format (tensor stream format)
  (let* ((n0 (car ($size tensor)))
         (n n0)
         (tr? nil)
         (maxn 8)
         (halfn 4))
    (when (> n maxn)
      (setf n maxn)
      (setf tr? t))
    (format stream "[")
    (loop :for i :from 0 :below n
          :do (let* ((i (if (and tr? (>= i halfn)) (- n0 (- maxn i)) i))
                     (v (tensor-at tensor i)))
                (if (< i (1- n0))
                    (if (and tr? (eq i (- n0 halfn)))
                        (format stream " ··· ~A " (format nil format v))
                        (format stream "~A " (format nil format v)))
                    (format stream "~A" (format nil format v)))))
    (format stream "]")))

(defun print-2d-format (tensor stream format &optional (indent "") (startp T))
  (let* ((sz ($size tensor))
         (nr0 ($0 sz))
         (nc0 ($1 sz))
         (nr nr0)
         (nc nc0)
         (maxn 8)
         (halfn 4)
         (rtr? nil)
         (ctr? nil))
    (when (> nr maxn)
      (setf rtr? t)
      (setf nr maxn))
    (when (> nc maxn)
      (setf ctr? t)
      (setf nc maxn))
    (format stream "~A[" (if startp "" indent))
    (loop :for i :from 0 :below nr
          :do (let ((i (if (and rtr? (>= i halfn)) (- nr0 (- maxn i)) i)))
                (format stream "~A[" (if (eq i 0) "" (concatenate 'string indent " ")))
                (loop :for j :from 0 :below nc
                      :do (let* ((j (if (and ctr? (>= j halfn)) (- nc0 (- maxn j)) j))
                                 (v (tensor-at tensor i j)))
                            (if (< j (1- nc0))
                                (if (and ctr? (= j (- nc0 halfn)))
                                    (format stream " ··· ~A " (format nil format v))
                                    (format stream "~A " (format nil format v)))
                                (format stream "~A]" (format nil format v)))))
                (if (and rtr? (= i (1- halfn)))
                    (format stream "~%~% ~A···~%~%" indent)
                    (if (= i (1- nr0))
                        (format stream "]")
                        (format stream "~%")))))))

(defun print-3d-format (tensor stream format &optional (indent "") (startp T))
  (let ((n0 ($ ($size tensor) 0))
        (ind (concatenate 'string " " indent))
        (nb 4))
    (format stream "~A[" (if startp "" indent))
    (if (< n0 (* 2 nb))
        (progn
          (loop :for i :from 0 :below n0
                :do (progn
                      (if (eq i 0)
                          (print-2d-format ($ tensor i) stream format ind T)
                          (print-2d-format ($ tensor i) stream format ind nil))
                      (if (eq i (1- n0))
                          (format stream "")
                          (format stream "~%~%"))))
          (format stream "]"))
        (progn
          (loop :for i :from 0 :below nb
                :do (progn
                      (if (eq i 0)
                          (print-2d-format ($ tensor i) stream format ind T)
                          (print-2d-format ($ tensor i) stream format ind nil))
                      (if (eq i (1- (min nb n0)))
                          (format stream "")
                          (format stream "~%~%"))))
          (format stream "~%~%~%~A ······~%~%~%" indent)
          (loop :for i :from (- n0 nb 1) :below n0
                :do (progn
                      (if (eq i 0)
                          (print-2d-format ($ tensor i) stream format ind T)
                          (print-2d-format ($ tensor i) stream format ind nil))
                      (if (eq i (1- n0))
                          (format stream "]")
                          (format stream "~%~%"))))))))

(defun print-4d-format (tensor stream format &optional (indent "") (startp T))
  (let ((n0 ($ ($size tensor) 0))
        (ind (concatenate 'string " " indent))
        (nb 4))
    (format stream "~A[" (if startp "" indent))
    (if (< n0 (* 2 nb))
        (progn
          (loop :for i :from 0 :below n0
                :do (progn
                      (if (eq i 0)
                          (print-3d-format ($ tensor i) stream format ind T)
                          (print-3d-format ($ tensor i) stream format ind nil))
                      (if (eq i (1- n0))
                          (format stream "")
                          (format stream "~%~%"))))
          (format stream "]"))
        (progn
          (loop :for i :from 0 :below nb
                :do (progn
                      (if (eq i 0)
                          (print-3d-format ($ tensor i) stream format ind T)
                          (print-3d-format ($ tensor i) stream format ind nil))
                      (if (eq i (1- (min 4 n0)))
                          (format stream "")
                          (format stream "~%~%"))))
          (format stream "~%~%~%~%~A ·········~%~%~%~%" indent)
          (loop :for i :from (- n0 nb 1) :below n0
                :do (progn
                      (if (eq i 0)
                          (print-3d-format ($ tensor i) stream format ind T)
                          (print-3d-format ($ tensor i) stream format ind nil))
                      (if (eq i (1- n0))
                          (format stream "]")
                          (format stream "~%~%"))))))))

(defun print-5d-format (tensor stream format &optional (indent "") (startp T))
  (let ((n0 ($ ($size tensor) 0))
        (ind (concatenate 'string " " indent))
        (nb 4))
    (format stream "~A[" (if startp "" indent))
    (if (< n0 (* 2 nb))
        (progn
          (loop :for i :from 0 :below n0
                :do (progn
                      (if (eq i 0)
                          (print-4d-format ($ tensor i) stream format ind T)
                          (print-4d-format ($ tensor i) stream format ind nil))
                      (if (eq i (1- n0))
                          (format stream "")
                          (format stream "~%~%"))))
          (format stream "]"))
        (progn
          (loop :for i :from 0 :below nb
                :do (progn
                      (if (eq i 0)
                          (print-4d-format ($ tensor i) stream format ind T)
                          (print-4d-format ($ tensor i) stream format ind nil))
                      (if (eq i (1- (min 4 n0)))
                          (format stream "")
                          (format stream "~%~%"))))
          (format stream "~%~%~%~%~%~A ············~%~%~%~%~%" indent)
          (loop :for i :from (- n0 nb 1) :below n0
                :do (progn
                      (if (eq i 0)
                          (print-4d-format ($ tensor i) stream format ind T)
                          (print-4d-format ($ tensor i) stream format ind nil))
                      (if (eq i (1- n0))
                          (format stream "]")
                          (format stream "~%~%"))))))))


(defun print-f12 (storage tensor stream)
  (let ((n (min ($size storage) (tensor-n-element tensor))))
    (format stream "#<~A ~A [~{~8F~^ ~}~A>" (type-of tensor) ($size tensor)
            (loop :for i :from 0 :below (min 5 n) :collect ($ storage i))
            (if (>= n 5) " ···]" "]"))))

(defun print-int4 (storage tensor stream)
  (let ((n (min ($size storage) (tensor-n-element tensor))))
    (format stream "#<~A ~A [~{~4D~^ ~}~A>" (type-of tensor) ($size tensor)
            (loop :for i :from 0 :below (min 5 n) :collect ($ storage i))
            (if (>= n 5) " ···]" "]"))))

(defun print-int6 (storage tensor stream)
  (let ((n (min ($size storage) (tensor-n-element tensor))))
    (format stream "#<~A ~A [~{~6D~^ ~}~A>" (type-of tensor) ($size tensor)
            (loop :for i :from 0 :below (min 5 n) :collect ($ storage i))
            (if (>= n 5) " ···]" "]"))))

(defun print-int12 (storage tensor stream)
  (let ((n (min ($size storage) (tensor-n-element tensor))))
    (format stream "#<~A ~A [~{~11D~^ ~}~A>" (type-of tensor) ($size tensor)
            (loop :for i :from 0 :below (min 5 n) :collect ($ storage i))
            (if (>= n 5) " ···]" "]"))))

(defmethod print-object ((tensor tensor.fractional) stream)
  (let ((storage ($storage tensor)))
    (if storage
        (let ((sz ($size tensor)))
          (cond ((eq 1 ($count sz)) (print-1d-format tensor stream "~8F"))
                ((eq 2 ($count sz)) (print-2d-format tensor stream "~8F"))
                ((eq 3 ($count sz)) (print-3d-format tensor stream "~8F"))
                ((eq 4 ($count sz)) (print-4d-format tensor stream "~8F"))
                ((eq 5 ($count sz)) (print-5d-format tensor stream "~8F"))
                (t (print-f12 storage tensor stream))))
        (format stream "[]"))))

(defmethod print-object ((tensor tensor.integral) stream)
  (let ((storage ($storage tensor)))
    (if storage
        (let ((sz ($size tensor)))
          (cond ((eq 1 ($count sz)) (print-1d-format tensor stream "~11D"))
                ((eq 2 ($count sz)) (print-2d-format tensor stream "~11D"))
                ((eq 3 ($count sz)) (print-3d-format tensor stream "~11D"))
                ((eq 4 ($count sz)) (print-4d-format tensor stream "~11D"))
                ((eq 5 ($count sz)) (print-5d-format tensor stream "~11D"))
                (t (print-int12 storage tensor stream))))
        (format stream "[]"))))

(defmethod print-object ((tensor tensor.byte) stream)
  (let ((storage ($storage tensor)))
    (if storage
        (let ((sz ($size tensor)))
          (cond ((eq 1 ($count sz)) (print-1d-format tensor stream "~4D"))
                ((eq 2 ($count sz)) (print-2d-format tensor stream "~4D"))
                ((eq 3 ($count sz)) (print-3d-format tensor stream "~4D"))
                ((eq 4 ($count sz)) (print-4d-format tensor stream "~4D"))
                ((eq 5 ($count sz)) (print-5d-format tensor stream "~4D"))
                (t (print-int4 storage tensor stream))))
        (format stream "[]"))))

(defmethod print-object ((tensor tensor.char) stream)
  (let ((storage ($storage tensor)))
    (if storage
        (let ((sz ($size tensor)))
          (cond ((eq 1 ($count sz)) (print-1d-format tensor stream "~4D"))
                ((eq 2 ($count sz)) (print-2d-format tensor stream "~4D"))
                ((eq 3 ($count sz)) (print-3d-format tensor stream "~4D"))
                ((eq 4 ($count sz)) (print-4d-format tensor stream "~4D"))
                ((eq 5 ($count sz)) (print-5d-format tensor stream "~4D"))
                (t (print-int4 storage tensor stream))))
        (format stream "[]"))))

(defmethod print-object ((tensor tensor.short) stream)
  (let ((storage ($storage tensor)))
    (if storage
        (let ((sz ($size tensor)))
          (cond ((eq 1 ($count sz)) (print-1d-format tensor stream "~6D"))
                ((eq 2 ($count sz)) (print-2d-format tensor stream "~6D"))
                ((eq 3 ($count sz)) (print-3d-format tensor stream "~6D"))
                ((eq 4 ($count sz)) (print-4d-format tensor stream "~6D"))
                ((eq 5 ($count sz)) (print-5d-format tensor stream "~6D"))
                (t (print-int6 storage tensor stream))))
        (format stream "[]"))))

(defmethod $tensorp ((tensor tensor)) t)
(defmethod $tensorp ((tensot t)) nil)

(defmethod $storage ((tensor tensor)) (when ($handle tensor) (tensor-storage tensor)))
(defmethod $offset ((tensor tensor)) (when ($handle tensor) (tensor-storage-offset tensor)))

(defmethod $ndim ((tensor tensor)) (when ($handle tensor) (tensor-n-dimension tensor)))
(defmethod $ndim ((tensor null)) 0)
(defmethod $ndim ((tensor t)) 0)

(defmethod $coerce ((tensor tensor.byte) value) (coerce value 'unsigned-byte))
(defmethod $coerce ((tensor tensor.char) value) (coerce value 'signed-byte))
(defmethod $coerce ((tensor tensor.short) value) (coerce value 'integer))
(defmethod $coerce ((tensor tensor.int) value) (coerce value 'integer))
(defmethod $coerce ((tensor tensor.long) value) (coerce value 'integer))
(defmethod $coerce ((tensor tensor.float) value) (coerce value 'single-float))
(defmethod $coerce ((tensor tensor.double) value) (coerce value 'double-float))

(defmethod $acoerce ((tensor tensor.byte) value) (coerce value 'integer))
(defmethod $acoerce ((tensor tensor.char) value) (coerce value 'integer))
(defmethod $acoerce ((tensor tensor.short) value) (coerce value 'integer))
(defmethod $acoerce ((tensor tensor.int) value) (coerce value 'integer))
(defmethod $acoerce ((tensor tensor.long) value) (coerce value 'integer))
(defmethod $acoerce ((tensor tensor.float) value) (coerce value 'double-float))
(defmethod $acoerce ((tensor tensor.double) value) (coerce value 'double-float))

(defmethod $type ((tensor tensor.byte)) :unsigned-char)
(defmethod $type ((tensor tensor.char)) :char)
(defmethod $type ((tensor tensor.short)) :short)
(defmethod $type ((tensor tensor.int)) :int)
(defmethod $type ((tensor tensor.long)) :long)
(defmethod $type ((tensor tensor.float)) :float)
(defmethod $type ((tensor tensor.double)) :double)

(defmethod $copy! ((tensor tensor) (source tensor))
  (tensor-copy tensor source)
  tensor)
(defmethod $copy! ((tensor tensor) (source list))
  (tensor-copy tensor (tensor source))
  tensor)

(defmethod $fill ((tensor tensor) (value number))
  (let ((result ($clone tensor)))
    (tensor-fill result value)
    result))

(defmethod $fill! ((tensor tensor) (value number))
  (tensor-fill tensor value)
  tensor)

(defmethod $size ((tensor tensor) &optional dimension)
  (when ($handle tensor)
    (cond ((null dimension) (let ((ndim (tensor-n-dimension tensor)))
                              (when (> ndim 0)
                                (mapcar (lambda (i) (tensor-size tensor i))
                                        (loop :for i :from 0 :below ndim :collect i)))))
          (t (tensor-size tensor dimension)))))
(defmethod $size ((tensor null) &optional dimension) (declare (ignore dimension)))
(defmethod $size ((tensor t) &optional dimension) (declare (ignore dimension)))

(defmethod $stride ((tensor tensor) &optional dimension)
  (when ($handle tensor)
    (cond ((null dimension) (let ((ndim (tensor-n-dimension tensor)))
                              (when (> ndim 0)
                                (mapcar (lambda (i) (tensor-stride tensor i))
                                        (loop :for i :from 0 :below ndim :collect i)))))
          (t (tensor-stride tensor dimension)))))
(defmethod $stride ((tensor null) &optional dimension) (declare (ignore dimension)))
(defmethod $stride ((tensor t) &optional dimension) (declare (ignore dimension)))

(defmethod $pointer ((tensor tensor)) (tensor-data tensor))

(defmethod $clone ((tensor tensor)) (tensor-clone tensor))
(defmethod $clone ((v T)) v)

(defmethod $contiguous! ((tensor tensor))
  (unless ($contiguousp tensor)
    (tensor-contiguous tensor))
  tensor)

(defmethod $contiguousp ((tensor tensor)) (tensor-contiguous-p tensor))

(defmethod $select ((tensor tensor) dimension slice-index)
  (tensor-new-select tensor dimension slice-index))

(defmethod $select! ((tensor tensor) dimension slice-index)
  (tensor-select tensor tensor dimension slice-index)
  tensor)

(defmethod (setf $select) (value (tensor tensor) dimension index)
  (let ((x ($select tensor dimension index)))
    ($copy! x value)
    value))

(defmethod $narrow ((tensor tensor) dimension first-index size)
  (tensor-new-narrow tensor dimension first-index size))

(defmethod $narrow! ((tensor tensor) dimension first-index size)
  (tensor-narrow tensor tensor dimension first-index size)
  tensor)

(defmethod (setf $narrow) (value (tensor tensor) dimension first-index size)
  (let ((x ($narrow tensor dimension first-index size)))
    ($copy! x value)
    value))

(defmethod $transpose ((tensor tensor) &optional dimension0 dimension1)
  (if (eq 1 ($ndim tensor))
      ($reshape tensor ($count tensor) 1)
      (cond ((and (null dimension0) (null dimension1)) (tensor-new-transpose tensor))
            (t (let ((result ($empty tensor)))
                 (tensor-transpose result tensor dimension0 dimension1)
                 result)))))

(defmethod $transpose ((n number) &optional dimension0 dimension1)
  (declare (ignore dimension0 dimension1))
  n)

(defmethod $transpose! ((tensor tensor) &optional dimension0 dimension1)
  (if (eq 1 ($ndim tensor))
      ($reshape! tensor ($count tensor) 1)
      (progn (tensor-transpose tensor tensor (or dimension0 0) (or dimension1 1))
             tensor)))

(defmethod $unfold ((tensor tensor) dimension size step)
  (tensor-new-unfold tensor dimension size step))

(defmethod $unfold! ((tensor tensor) dimension size step)
  (tensor-unfold tensor tensor dimension size step)
  tensor)

(defmethod $view ((tensor tensor) &rest sizes)
  (cond (($tensorp ($0 sizes)) (tensor-new-view tensor ($size ($0 sizes))))
        (t (tensor-new-view tensor sizes))))

(defmethod $set! ((tensor tensor) (source tensor) &optional offset size stride)
  (declare (ignore offset size stride))
  (tensor-set tensor source)
  tensor)

(defmethod $set! ((tensor tensor) (source storage) &optional offset size stride)
  (tensor-set-storage tensor source offset size stride)
  tensor)

(defmethod $setp ((tensor tensor) (source tensor))
  (tensor-set-to-p tensor source))

(defmethod $sizep ((tensor tensor) (other tensor))
  (tensor-same-size-p tensor other))

(defmethod $sizep ((tensor tensor) (other list))
  (tensor-size-p tensor other))

(defmethod $sizep ((tensor tensor) (other storage.long))
  (tensor-size-p tensor other))

(defmethod $expand ((tensor tensor) size)
  (let ((result ($empty tensor)))
    (tensor-expand result tensor size)
    result))

(defmethod $expand! ((tensor tensor) size)
  (tensor-expand tensor tensor size)
  tensor)

(defmethod $resize! ((tensor tensor) (size list) &optional stride)
  (tensor-resize tensor size stride)
  tensor)

(defmethod $resize! ((tensor tensor) (other tensor) &optional stride)
  (declare (ignore stride))
  (tensor-resize-as tensor other)
  tensor)

(defmethod $resize! ((tensor tensor) (size storage.long) &optional stride)
  (tensor-resize tensor ($list size) ($list stride))
  tensor)

(defmethod $zero ((tensor tensor))
  (let ((nt ($empty tensor)))
    ($resize! nt tensor)
    (tensor-zero nt)
    nt))

(defmethod $zero ((x number))
  (declare (ignore x))
  0D0)

(defmethod $zero! ((tensor tensor))
  (tensor-zero tensor)
  tensor)

(defmethod $one ((tensor tensor))
  (let ((nt ($empty tensor)))
    ($resize! nt tensor)
    (tensor-fill nt 1)
    nt))

(defmethod $one ((x number))
  (declare (ignore x))
  1D0)

(defmethod $one! ((tensor tensor))
  (tensor-fill tensor 1)
  tensor)

(defmethod $subview ((tensor tensor) &rest index-sizes)
  (let ((cx ($narrow tensor 0 (car index-sizes) (cadr index-sizes)))
        (dim 1))
    (loop :for (i s) :on (cddr index-sizes) :by #'cddr
          :do (progn ($narrow! cx dim i s)
                     (incf dim)))
    cx))

(defmethod (setf $subview) (value (tensor tensor) &rest index-sizes)
  (let ((x (apply #'$subview tensor index-sizes)))
    ($copy! x value)
    value))

(defmethod $list ((tensor tensor)) ($list ($storage tensor)))

(defmethod $compare (spec (a tensor) (b tensor))
  (let ((result (tensor.byte)))
    (tensor-compare spec result a b)
    result))

(defmethod $compare (spec (a tensor) (b number))
  (let ((result (tensor.byte)))
    (tensor-compare spec result a b)
    result))

(defmethod $lt ((a tensor) (b tensor)) ($compare :lt a b))
(defmethod $lt ((a tensor) (b number)) ($compare :lt a b))
(defmethod $lt ((a number) (b tensor)) ($compare :ge b a))
(defmethod $lt ((a number) (b number)) (if (< a b) 1 0))

(defmethod $le ((a tensor) (b tensor)) ($compare :le a b))
(defmethod $le ((a tensor) (b number)) ($compare :le a b))
(defmethod $le ((a number) (b tensor)) ($compare :gt b a))
(defmethod $le ((a number) (b number)) (if (<= a b) 1 0))

(defmethod $gt ((a tensor) (b tensor)) ($compare :gt a b))
(defmethod $gt ((a tensor) (b number)) ($compare :gt a b))
(defmethod $gt ((a number) (b tensor)) ($compare :le b a))
(defmethod $gt ((a number) (b number)) (if (> a b) 1 0))

(defmethod $ge ((a tensor) (b tensor)) ($compare :ge a b))
(defmethod $ge ((a tensor) (b number)) ($compare :ge a b))
(defmethod $ge ((a number) (b tensor)) ($compare :lt b a))
(defmethod $ge ((a number) (b number)) (if (>= a b) 1 0))

(defmethod $eq ((a tensor) (b tensor)) ($compare :eq a b))
(defmethod $eq ((a tensor) (b number)) ($compare :eq a b))
(defmethod $eq ((a number) (b tensor)) ($compare :eq b a))
(defmethod $eq ((a number) (b number)) (if (= a b) 1 0))

(defmethod $ne ((a tensor) (b tensor)) ($compare :ne a b))
(defmethod $ne ((a tensor) (b number)) ($compare :ne a b))
(defmethod $ne ((a number) (b tensor)) ($compare :ne b a))
(defmethod $ne ((a number) (b number)) (if (not (= a b)) 1 0))

(defmethod $index ((tensor tensor) dimension (indices list))
  (let ((result ($empty tensor)))
    (tensor-index-select result tensor dimension (tensor.long indices))
    result))

(defmethod $index ((tensor tensor) dimension (index number))
  (let ((result ($empty tensor)))
    (tensor-index-select result tensor dimension (tensor.long (list index)))
    result))

(defmethod $index ((tensor tensor) dimension (indices tensor.long))
  (let ((result ($empty tensor)))
    (tensor-index-select result tensor dimension indices)
    result))

(defmethod $index ((tensor tensor) dimension (indices tensor.int))
  (let ((result ($empty tensor)))
    (tensor-index-select result tensor dimension (tensor.long indices))
    result))

(defmethod (setf $index) ((value number) (tensor tensor) dimension (indices list))
  (tensor-index-fill tensor value dimension (tensor.long indices))
  value)

(defmethod (setf $index) ((value number) (tensor tensor) dimension (index number))
  (tensor-index-fill tensor value dimension (tensor.long (list index)))
  value)

(defmethod (setf $index) ((value number) (tensor tensor) dimension (indices tensor.long))
  (tensor-index-fill tensor value dimension indices)
  value)

(defmethod (setf $index) ((value number) (tensor tensor) dimension (indices tensor.int))
  (tensor-index-fill tensor value dimension (tensor.long indices))
  value)

(defmethod (setf $index) ((value tensor) (tensor tensor) dimension (indices list))
  (tensor-index-copy tensor value dimension (tensor.long indices))
  value)

(defmethod (setf $index) ((value tensor) (tensor tensor) dimension (index number))
  (tensor-index-copy tensor value dimension (tensor.long (list index)))
  value)

(defmethod (setf $index) ((value tensor) (tensor tensor) dimension (indices tensor.long))
  (tensor-index-copy tensor value dimension indices)
  value)

(defmethod (setf $index) ((value tensor) (tensor tensor) dimension (indices tensor.int))
  (tensor-index-copy tensor value dimension (tensor.long indices))
  value)

(defmethod (setf $index) ((value list) (tensor tensor) dimension (indices list))
  (tensor-index-copy tensor (make-tensor-args (type-of tensor) (list value))
                     dimension (storage.long indices))
  value)

(defmethod (setf $index) ((value list) (tensor tensor) dimension (index number))
  (tensor-index-copy tensor (make-tensor-args (type-of tensor) (list value))
                     dimension (storage.long (list index)))
  value)

(defmethod (setf $index) ((value list) (tensor tensor) dimension (indices tensor.long))
  (tensor-index-copy tensor (make-tensor-args (type-of tensor) (list value))
                     dimension indices)
  value)

(defmethod (setf $index) ((value list) (tensor tensor) dimension (indices tensor.int))
  (tensor-index-copy tensor (make-tensor-args (type-of tensor) (list value))
                     dimension (tensor.long indices))
  value)

(defmethod $gather ((tensor tensor) dimension (indices list))
  (let ((result ($empty tensor))
        (indices (tensor.long indices)))
    ($resize! result indices)
    (tensor-gather result tensor dimension indices)
    result))

(defmethod $gather ((tensor tensor) dimension (indices tensor))
  (let ((result ($empty tensor)))
    ($resize! result indices)
    (tensor-gather result tensor dimension indices)
    result))

(defmethod $scatter! ((tensor tensor) dimension (indices list) (value tensor))
  (let ((indices (tensor.long indices)))
    (tensor-scatter tensor value dimension indices)
    tensor))

(defmethod $scatter! ((tensor tensor) dimension (indices list) (value list))
  (let ((indices (tensor.long indices)))
    (tensor-scatter tensor (make-tensor-args (type-of tensor) (list value)) dimension indices)
    tensor))

(defmethod $scatter! ((tensor tensor) dimension (indices list) (value number))
  (let ((indices (tensor.long indices)))
    (tensor-scatter-fill tensor value dimension indices)
    tensor))

(defmethod $scatter! ((tensor tensor) dimension (indices tensor.long) (value tensor))
  (tensor-scatter tensor value dimension indices)
  tensor)

(defmethod $scatter! ((tensor tensor) dimension (indices tensor.long) (value list))
  (tensor-scatter tensor (make-tensor-args (type-of tensor) (list value)) dimension indices)
  tensor)

(defmethod $scatter! ((tensor tensor) dimension (indices tensor.long) (value number))
  (tensor-scatter-fill tensor value dimension indices)
  tensor)

(defmethod $masked ((tensor tensor) (mask tensor.byte))
  (let ((result ($empty tensor)))
    (tensor-masked-select result mask tensor)
    result))

(defmethod $masked ((tensor tensor) (mask list))
  (let ((result ($empty tensor)))
    (tensor-masked-select result (make-tensor-args 'tensor.byte (list mask)) tensor)
    result))

(defmethod (setf $masked) ((value number) (tensor tensor) (mask tensor.byte))
  (tensor-masked-fill tensor mask value)
  value)
(defmethod (setf $masked) ((value number) (tensor tensor) (mask list))
  (tensor-masked-fill tensor (tensor.byte mask) value)
  value)

(defmethod (setf $masked) ((value tensor) (tensor tensor) (mask tensor.byte))
  (tensor-masked-copy tensor mask value)
  value)
(defmethod (setf $masked) ((value tensor) (tensor tensor) (mask list))
  (tensor-masked-copy tensor (tensor.byte mask) value)
  value)

(defmethod (setf $masked) ((value list) (tensor tensor) (mask tensor.byte))
  (tensor-masked-copy tensor mask (make-tensor-args (type-of tensor) (list value)))
  value)
(defmethod (setf $masked) ((value list) (tensor tensor) (mask list))
  (tensor-masked-copy tensor (tensor.byte mask) (make-tensor-args (type-of tensor) (list value)))
  value)

(defmethod $nonzero ((tensor tensor)) (tensor-non-zero tensor))

(defmethod $repeat ((tensor tensor) &rest sizes)
  (warn "$repeat method does not work correctly")
  (let* ((result ($clone tensor))
         (tensor (if ($contiguousp tensor) tensor ($clone tensor)))
         (size (if (eq 1 ($count sizes))
                   (append sizes '(1))
                   (copy-list sizes)))
         (xtensor ($clone tensor))
         (xsize ($size xtensor))
         (xsize (progn (loop :for i :from 0 :below (- ($count size) ($ndim tensor))
                             :do (push 1 xsize))
                       xsize))
         (size-tensor (tensor-cmul (tensor.long) (tensor.long xsize) (tensor.long size)))
         (size (loop :for i :from 0 :below ($count size-tensor)
                     :collect ($ ($storage size-tensor) i)))
         (result ($resize! result size))
         (urtensor ($clone result))
         (xtensor ($resize! xtensor xsize)))
    (loop :for i :from 0 :below ($ndim xtensor)
          :for xs = ($size xtensor i)
          :do (setf urtensor ($unfold urtensor i xs xs)))
    (loop :for i :from 0 :below (- ($ndim urtensor) ($ndim xtensor))
          :do (push 1 xsize))
    ($resize! xtensor xsize)
    ($copy! urtensor ($expand xtensor ($size urtensor)))
    result))

;; XXX this should be better
;; (let ((a (tensor '(1 1)))
;;       (b (zeros 2 2)))
;;   (setf ($subview b 0 1 0 2) a)
;;   (prn a)
;;   (prn b))

(defmethod $repeat ((n number) &rest sizes)
  (let ((result (apply #'tensor sizes)))
    ($fill! result n)
    result))

(defmethod $squeeze ((tensor tensor) &optional dimension)
  (let ((result ($empty tensor)))
    (tensor-squeeze result tensor dimension)
    result))

(defmethod $squeeze! ((tensor tensor) &optional dimension)
  (tensor-squeeze tensor tensor dimension)
  tensor)

(defmethod $unsqueeze ((tensor tensor) dimension)
  (let ((result ($empty tensor)))
    (tensor-unsqueeze result tensor dimension)
    result))

(defmethod $unsqueeze! ((tensor tensor) dimension)
  (tensor-unsqueeze tensor tensor dimension)
  tensor)

(defmethod $permute ((tensor tensor) &rest dimensions)
  (let ((out (tensor tensor))
        (perms (copy-list dimensions)))
    (loop :for i :from 0 :below ($ndim tensor)
          :for p = ($ perms i)
          :when (and (not (eq i p)) (not (eq p -1)))
            :do (let ((j i))
                  (loop :until (eq i ($ perms j))
                        :do (progn (setf out ($transpose out j ($ perms j)))
                                   (let ((oldj j))
                                     (setf j ($ perms j)
                                           ($ perms oldj) -1))))
                  (setf ($ perms j) j)))
    out))

(defmethod $fmap (fn (tensor tensor) &rest tensors)
  (let* ((result ($empty tensor))
         (s ($storage tensor)))
    ($resize! result tensor)
    (loop :for i :from 0 :below ($count s)
          :for x = ($ s i)
          :for ys = (mapcar (lambda (aten) ($ aten i)) tensors)
          :do (let ((v (apply #'funcall fn x ys)))
                (when v (setf ($ ($storage result) i) v))))
    result))

(defmethod $fmap! (fn (tensor tensor) &rest tensors)
  (let ((s ($storage tensor)))
    (loop :for i :from 0 :below ($count s)
          :for x = ($ s i)
          :for ys = (mapcar (lambda (aten) ($ aten i)) tensors)
          :do (let ((v (apply #'funcall fn x ys)))
                (when v (setf ($ s i) v))))
    tensor))

(defmethod $split ((tensor tensor) size &optional (dimension 0))
  (let* ((dlen ($size tensor dimension))
         (pcnt (floor (/ dlen size)))
         (remlen (- dlen (* pcnt size))))
    (append (loop :for i :from 0 :below pcnt
                  :for si = (* size i)
                  :collect ($narrow tensor dimension si size))
            (when (> remlen 0)
              (list ($narrow tensor dimension (* pcnt size) remlen))))))

(defmethod $chunk ((tensor tensor) n &optional (dimension 0))
  ($split tensor (ceiling (/ ($size tensor dimension) n)) dimension))

(defmethod $cat ((tensor tensor) (other tensor) &optional (dimension 0))
  (let ((result ($empty tensor)))
    (tensor-cat2 result dimension tensor other)
    result))

(defmethod $cat! ((tensor tensor) (other tensor) &optional (dimension 0))
  (tensor-cat2 tensor dimension tensor other)
  tensor)

(defmethod $catn ((tensors list) &optional (dimension 0))
  (tensor-catn (tensor) dimension tensors))

(defmethod $concat ((tensor tensor) other &rest tensors)
  (let ((pd ($last tensors)))
    (if (numberp pd)
        (let ((dimension pd)
              (xs (cons tensor (cons other (butlast tensors))))
              (result ($empty tensor)))
          (apply #'tensor-cat result dimension xs)
          result)
        (let ((dimension 0)
              (xs (cons tensor (cons other tensors)))
              (result ($empty tensor)))
          (apply #'tensor-cat result dimension xs)
          result))))

(defmethod $diag ((tensor tensor) &optional (k 0))
  (let ((result ($empty tensor)))
    (tensor-diag result tensor k)))

(defmethod $diag! ((tensor tensor) &optional (k 0))
  (tensor-diag tensor tensor k))

(defmethod $eye ((tensor tensor) m &optional n)
  (let ((result ($empty tensor))
        (n (or n m)))
    (tensor-eye result m n)
    result))

(defmethod $eye! ((tensor tensor) m &optional n)
  (let ((n (or n m)))
    (tensor-eye tensor m n)
    tensor))

(defmethod $ ((tensor tensor) (location number) &rest others-and-default)
  (let ((locs (cons location others-and-default)))
    (cond ((= ($ndim tensor) ($count locs))
           (let ((idx (+ ($offset tensor) (loop :for i :from 0 :below ($count locs)
                                                :sum (* ($ locs i) ($stride tensor i))))))
             ($ ($storage tensor) idx)))
          ((> ($ndim tensor) ($count locs))
           (let ((cx (tensor-new-select tensor 0 ($ locs 0))))
             (loop :for i :from 1 :below ($count locs)
                   :do (tensor-select cx cx 0 ($ locs i)))
             cx)))))

(defmethod $ ((tensor tensor) (location list) &rest others-and-default)
  (labels ((lspec (l) (loop :for i :from 0 :below ($count l)
                            :for e = ($ l i)
                            :collect (if (eq :all e)
                                         (list 0 ($size tensor i))
                                         e)))
           (flattenl (l) (cond ((null l) nil)
                               ((atom (car l)) (cons (car l) (flattenl (cdr l))))
                               (t (append (flattenl (car l)) (flattenl (cdr l)))))))
    (apply #'$subview tensor (flattenl (lspec (append location others-and-default))))))

(defmethod $ ((tensor tensor) (location tensor.byte) &rest others-and-default)
  (declare (ignore others-and-default))
  (let ((result ($empty tensor)))
    (tensor-masked-select result location tensor)
    result))

(defmethod $ ((list list) (location tensor.int) &rest others-and-default)
  (if (eq 1 ($count location))
      ($ list ($ ($squeeze location) 0) others-and-default)
      (error "cannot use location of dimension = ~A" ($ndim location))))

(defmethod $ ((list list) (location tensor.long) &rest others-and-default)
  (if (eq 1 ($count location))
      ($ list ($ ($squeeze location) 0) others-and-default)
      (error "cannot use location of dimension = ~A" ($ndim location))))

(defmethod $ ((list array) (location tensor.int) &rest others-and-default)
  (if (eq 1 ($count location))
      ($ list ($ ($squeeze location) 0) others-and-default)
      (error "cannot use location of dimension = ~A" ($ndim location))))

(defmethod $ ((list array) (location tensor.long) &rest others-and-default)
  (if (eq 1 ($count location))
      ($ list ($ ($squeeze location) 0) others-and-default)
      (error "cannot use location of dimension = ~A" ($ndim location))))

(defmethod (setf $) ((value number) (tensor tensor) (location number) &rest others)
  (let ((locs (cons location others)))
    (cond ((eq ($count locs) ($ndim tensor))
           (let ((s ($storage tensor)))
             (setf ($ s (+ ($offset tensor)
                           (loop :for i :from 0 :below ($count locs)
                                 :sum (* ($ locs i) ($stride tensor i)))))
                   value)))
          ((> ($ndim tensor) ($count locs))
           (let ((cx (tensor-new-select tensor 0 ($ locs 0))))
             (loop :for i :from 1 :below ($count locs)
                   :do (tensor-select cx cx 0 ($ locs i)))
             (tensor-fill cx value))))
    value))

(defmethod (setf $) ((value tensor) (tensor tensor) (location number) &rest others)
  (let ((locs (cons location others)))
    (when (> ($ndim tensor) ($count locs))
      (let ((cx (tensor-new-select tensor 0 ($ locs 0))))
        (loop :for i :from 1 :below ($count locs)
              :do (tensor-select cx cx 0 ($ locs i)))
        (tensor-copy cx value)
        value))))

(defmethod (setf $) ((value list) (tensor tensor) (location number) &rest others)
  (let ((locs (cons location others)))
    (when (> ($ndim tensor) ($count locs))
      (let ((cx (tensor-new-select tensor 0 ($ locs 0))))
        (loop :for i :from 1 :below ($count locs)
              :do (tensor-select cx cx 0 ($ locs i)))
        (tensor-copy cx (make-tensor-args (type-of tensor) (list value)))
        value))))

(defmethod (setf $) ((value number) (tensor tensor) (location list) &rest others)
  (labels ((lspec (l) (loop :for i :from 0 :below ($count l)
                            :for e = ($ l i)
                            :collect (if (eq :all e)
                                         (list 0 ($size tensor i))
                                         e)))
           (flattenl (l) (cond ((null l) nil)
                               ((atom (car l)) (cons (car l) (flattenl (cdr l))))
                               (t (append (flattenl (car l)) (flattenl (cdr l)))))))
    (let ((x (apply #'$subview tensor (flattenl (lspec (append location others))))))
      (tensor-fill x value))
    value))

(defmethod (setf $) ((value tensor) (tensor tensor) (location list) &rest others)
  (labels ((lspec (l) (loop :for i :from 0 :below ($count l)
                            :for e = ($ l i)
                            :collect (if (eq :all e)
                                         (list 0 ($size tensor i))
                                         e)))
           (flattenl (l) (cond ((null l) nil)
                               ((atom (car l)) (cons (car l) (flattenl (cdr l))))
                               (t (append (flattenl (car l)) (flattenl (cdr l)))))))
    (let ((x (apply #'$subview tensor (flattenl (lspec (append location others))))))
      (tensor-copy x value))
    value))

(defmethod (setf $) ((value list) (tensor tensor) (location list) &rest others)
  (labels ((lspec (l) (loop :for i :from 0 :below ($count l)
                            :for e = ($ l i)
                            :collect (if (eq :all e)
                                         (list 0 ($size tensor i))
                                         e)))
           (flattenl (l) (cond ((null l) nil)
                               ((atom (car l)) (cons (car l) (flattenl (cdr l))))
                               (t (append (flattenl (car l)) (flattenl (cdr l)))))))
    (let ((x (apply #'$subview tensor (flattenl (lspec (append location others))))))
      (tensor-copy x (make-tensor-args (type-of tensor) (list value))))
    value))

(defmethod (setf $) ((value number) (tensor tensor) (location tensor.byte) &rest others)
  (declare (ignore others))
  (tensor-masked-fill tensor location value)
  value)

(defmethod (setf $) ((value tensor) (tensor tensor) (location tensor.byte) &rest others)
  (declare (ignore others))
  (tensor-masked-copy tensor location value)
  value)

(defmethod (setf $) ((value list) (tensor tensor) (location tensor.byte) &rest others)
  (declare (ignore others))
  (tensor-masked-copy tensor location (make-tensor-args (type-of tensor) (list value)))
  value)

(defmethod $reshape ((tensor tensor) &rest sizes)
  (let ((result ($empty tensor)))
    (tensor-reshape result tensor (storage.long sizes))
    result))

(defmethod $reshape! ((tensor tensor) &rest sizes)
  (tensor-reshape tensor tensor (storage.long sizes))
  tensor)

(defmethod $tril ((tensor tensor) &optional (k 0))
  (let ((result ($empty tensor)))
    (tensor-tri-l result tensor k)
    result))

(defmethod $tril! ((tensor tensor) &optional (k 0))
  (tensor-tri-l tensor tensor k)
  tensor)

(defmethod $triu ((tensor tensor) &optional (k 0))
  (let ((result ($empty tensor)))
    (tensor-tri-u result tensor k)
    result))

(defmethod $triu! ((tensor tensor) &optional (k 0))
  (tensor-tri-u tensor tensor k)
  tensor)

(defmethod $abs ((x number)) (abs x))
(defmethod $abs! ((x number)) (abs x))

(defmethod $abs ((x tensor)) (tensor-abs ($empty x) x))
(defmethod $abs! ((x tensor)) (tensor-abs x x))

(defmethod $sign ((x number)) (signum x))
(defmethod $sign! ((x number)) (signum x))

(defmethod $sign ((x tensor)) (tensor-sign ($empty x) x))
(defmethod $sign! ((x tensor)) (tensor-sign x x))

(defmethod $acos ((x number)) (acos x))
(defmethod $acos! ((x number)) (acos x))

(defmethod $acos ((x tensor)) (tensor-acos ($empty x) x))
(defmethod $acos! ((x tensor)) (tensor-acos x x))

(defmethod $asin ((x number)) (asin x))
(defmethod $asin! ((x number)) (asin x))

(defmethod $asin ((x tensor)) (tensor-asin ($empty x) x))
(defmethod $asin! ((x tensor)) (tensor-asin x x))

(defmethod $atan ((y number)) (atan y))
(defmethod $atan! ((y number)) (atan y))

(defmethod $atan ((y tensor)) (tensor-atan ($empty y) y))
(defmethod $atan! ((y tensor)) (tensor-atan y y))

(defmethod $atan2 ((y number) (x number)) (atan y x))
(defmethod $atan2! ((y number) (x number)) (atan y x))

(defmethod $atan2 ((y tensor) (x tensor)) (tensor-atan2 ($empty y) y x))
(defmethod $atan2! ((y tensor) (x tensor)) (tensor-atan2 y y x))

(defmethod $ceil ((x number)) (ceiling x))
(defmethod $ceil! ((x number)) (ceiling x))

(defmethod $ceil ((x tensor)) (tensor-ceil ($empty x) x))
(defmethod $ceil! ((x tensor)) (tensor-ceil x x))

(defmethod $cos ((x number)) (cos x))
(defmethod $cos! ((x number)) (cos x))

(defmethod $cos ((x tensor)) (tensor-cos ($empty x) x))
(defmethod $cos! ((x tensor)) (tensor-cos x x))

(defmethod $cosh ((x number)) (cosh x))
(defmethod $cosh! ((x number)) (cosh x))

(defmethod $cosh ((x tensor)) (tensor-cosh ($empty x) x))
(defmethod $cosh! ((x tensor)) (tensor-cosh x x))

(defmethod $exp ((x number)) (exp x))
(defmethod $exp! ((x number)) (exp x))

(defmethod $exp ((x tensor)) (tensor-exp ($empty x) x))
(defmethod $exp! ((x tensor)) (tensor-exp x x))

(defmethod $floor ((x number)) (floor x))
(defmethod $floor! ((x number)) (floor x))

(defmethod $floor ((x tensor)) (tensor-floor ($empty x) x))
(defmethod $floor! ((x tensor)) (tensor-floor x x))

(defmethod $log ((x number)) (log x))
(defmethod $log! ((x number)) (log x))

(defmethod $log ((x tensor)) (tensor-log ($empty x) x))
(defmethod $log! ((x tensor)) (tensor-log x x))

(defmethod $lgammaf ((x tensor)) (tensor-lgamma ($empty x) x))
(defmethod $lgammaf! ((x tensor)) (tensor-lgamma x x))

(defmethod $gammaf ((x tensor)) (tensor-gamma ($empty x) x))
(defmethod $gammaf! ((x tensor)) (tensor-gamma x x))

(defmethod $betaf ((x tensor) (y tensor))
  ($div! ($mul ($gammaf x) ($gammaf y)) ($gammaf ($add x y))))
(defmethod $betaf! ((x tensor) (y tensor))
  (let ((gxy ($gammaf ($add x y)))
        (gx ($gammaf! x))
        (gy ($gammaf y)))
    ($div! ($mul! gx gy) gxy)))

(defmethod $lbetaf ((x tensor) (y tensor))
  (tensor-lbeta ($resize! ($empty x) ($size x) ($stride x)) x y))
(defmethod $lbetaf! ((a tensor) (b tensor))
  (tensor-lbeta a ($clone a) b))

(defmethod $polygamma ((x tensor) n)
  (tensor-polygamma ($resize! ($empty x) ($size x) ($stride x)) x n))
(defmethod $polygamma! ((x tensor) n)
  (tensor-polygamma x ($clone x) n))

(defmethod $erf ((x tensor)) (tensor-erf ($empty x) x))
(defmethod $erf! ((x tensor)) (tensor-erf x x))

(defmethod $erfc ((x tensor)) (tensor-erfc ($empty x) x))
(defmethod $erfc! ((x tensor)) (tensor-erfc x x))

(defmethod $log1p ((x number)) (log (1+ x)))
(defmethod $log1p! ((x number)) (log (1+ x)))

(defmethod $log1p ((x tensor)) (tensor-log1p ($empty x) x))
(defmethod $log1p! ((x tensor)) (tensor-log1p x x))

(defmethod $neg ((x number)) (- x))
(defmethod $neg! ((x number)) (- x))

(defmethod $neg ((x tensor)) (tensor-neg ($empty x) x))
(defmethod $neg! ((x tensor)) (tensor-neg x x))

(defmethod $cinv ((x number)) (/ 1 x))
(defmethod $cinv! ((x number)) (/ 1 x))

(defmethod $cinv ((x tensor)) (tensor-cinv ($empty x) x))
(defmethod $cinv! ((x tensor)) (tensor-cinv x x))

(defmethod $expt ((x number) (n number)) (expt x n))
(defmethod $expt! ((x number) (n number)) (expt x n))

(defmethod $expt ((x tensor) (n number)) (tensor-pow ($empty x) x n))
(defmethod $expt ((x number) (n tensor)) (tensor-pow ($empty n) x n))

(defmethod $expt! ((x tensor) (n number)) (tensor-pow x x n))
(defmethod $expt! ((x number) (n tensor)) (tensor-pow n x n))

(defmethod $expt ((x tensor) (n tensor)) (tensor-cpow ($empty x) x n))
(defmethod $expt! ((x tensor) (n tensor)) (tensor-cpow x x n))

(defmethod $round ((x number)) (round x))
(defmethod $round! ((x number)) (round x))

(defmethod $round ((x tensor)) (tensor-round ($empty x) x))
(defmethod $round! ((x tensor)) (tensor-round x x))

(defmethod $sin ((x number)) (sin x))
(defmethod $sin! ((x number)) (sin x))

(defmethod $sin ((x tensor)) (tensor-sin ($empty x) x))
(defmethod $sin! ((x tensor)) (tensor-sin x x))

(defmethod $sinh ((x number)) (sinh x))
(defmethod $sinh! ((x number)) (sinh x))

(defmethod $sinh ((x tensor)) (tensor-sinh ($empty x) x))
(defmethod $sinh! ((x tensor)) (tensor-sinh x x))

(defmethod $sqrt ((x number)) (sqrt x))
(defmethod $sqrt! ((x number)) (sqrt x))

(defmethod $sqrt ((x tensor)) (tensor-sqrt ($empty x) x))
(defmethod $sqrt! ((x tensor)) (tensor-sqrt x x))

(defmethod $rsqrt ((x number)) (/ 1 (sqrt x)))
(defmethod $rsqrt! ((x number)) (/ 1 (sqrt x)))

(defmethod $rsqrt ((x tensor)) (tensor-rsqrt ($empty x) x))
(defmethod $rsqrt! ((x tensor)) (tensor-rsqrt x x))

(defmethod $tan ((x number)) (tan x))
(defmethod $tan! ((x number)) (tan x))

(defmethod $tan ((x tensor)) (tensor-tan ($empty x) x))
(defmethod $tan! ((x tensor)) (tensor-tan x x))

(defmethod $tanh ((x number)) (tanh x))
(defmethod $tanh! ((x number)) (tanh x))

(defmethod $tanh ((x tensor)) (tensor-tanh ($empty x) x))
(defmethod $tanh! ((x tensor)) (tensor-tanh x x))

(defmethod $sigmoid ((x number)) (/ 1 (1+ (exp (- x)))))
(defmethod $sigmoid! ((x number)) (/ 1 (1+ (exp (- x)))))

(defmethod $sigmoid ((x tensor)) (tensor-sigmoid ($empty x) x))
(defmethod $sigmoid! ((x tensor)) (tensor-sigmoid x x))

(defmethod $trunc ((x number)) (truncate x))
(defmethod $trunc! ((x number)) (truncate x))

(defmethod $trunc ((x tensor)) (tensor-trunc ($empty x) x))
(defmethod $trunc! ((x tensor)) (tensor-trunc x x))

(defmethod $frac ((x number)) (- x (truncate x)))
(defmethod $frac! ((x number)) (- x (truncate x)))

(defmethod $frac ((x tensor)) (tensor-frac ($empty x) x))
(defmethod $frac! ((x tensor)) (tensor-frac x x))

(defmethod $equal ((x t) (y t)) (equal x y))
(defmethod $equal ((x list) (y list)) (eq 0 (reduce #'+ (mapcar (lambda (a b) (if (eq a b) 0 1)) x y))))
(defmethod $equal ((x tensor) (y tensor)) (tensor-equal x y))

(defmethod $clamp ((x tensor) (min number) (max number))
  (let ((result ($empty x)))
    (tensor-clamp result x min max)
    result))
(defmethod $clamp! ((x tensor) (min number) (max number))
  (tensor-clamp x x min max)
  x)

(defmethod $axpy ((α number) (x tensor) (y tensor))
  (let ((result ($empty y)))
    (tensor-cadd result y α x)
    result))

(defmethod $axpy! ((α number) (x tensor) (y tensor))
  (tensor-cadd y y α x)
  y)

(defmethod $add ((y tensor) (x number))
  (let ((result ($empty y)))
    (tensor-add result y x)
    result))
(defmethod $add ((y tensor) (x tensor))
  (let ((result ($empty y)))
    (tensor-cadd result y 1 x)
    result))
(defmethod $add ((y number) (x number)) (+ y x))
(defmethod $add ((y number) (x tensor))
  (let ((result ($empty x)))
    (tensor-add result x y)
    result))

(defmethod $add! ((y tensor) (x number))
  (tensor-add y y x)
  y)
(defmethod $add! ((y tensor) (x tensor))
  (tensor-cadd y y 1 x)
  y)
(defmethod $add! ((y number) (x number)) (+ y x))

(defmethod $sub ((y tensor) (x number))
  (let ((result ($empty y)))
    (tensor-sub result y x)
    result))
(defmethod $sub ((y tensor) (x tensor))
  (let ((result ($empty y)))
    (tensor-csub result y 1 x)
    result))
(defmethod $sub ((y number) (x number)) (- y x))
(defmethod $sub ((y number) (x tensor))
  (let ((result ($empty x)))
    (tensor-sub result x y)
    ($neg! result)))

(defmethod $sub! ((y tensor) (x number))
  (tensor-sub y y x)
  y)
(defmethod $sub! ((y tensor) (x tensor))
  (tensor-csub y y 1 x)
  y)
(defmethod $sub! ((y number) (x number)) (- y x))

(defmethod $mul ((y tensor) (x number))
  (let ((result ($empty y)))
    (tensor-mul result y x)
    result))
(defmethod $mul ((y tensor) (x tensor))
  (let ((result ($empty y)))
    (tensor-cmul result y x)
    result))
(defmethod $mul ((y number) (x number)) (* y x))
(defmethod $mul ((y number) (x tensor))
  (let ((result ($empty x)))
    (tensor-mul result x y)
    result))

(defmethod $mul! ((y tensor) (x number))
  (tensor-mul y y x)
  y)
(defmethod $mul! ((y tensor) (x tensor))
  (tensor-cmul y y x)
  y)
(defmethod $mul! ((y number) (x number)) (* y x))

(defmethod $div ((y tensor) (x number))
  (let ((result ($empty y)))
    (tensor-div result y x)
    result))
(defmethod $div ((y tensor) (x tensor))
  (let ((result ($empty y)))
    (tensor-cdiv result y x)
    result))
(defmethod $div ((y number) (x number)) (/ y x))
(defmethod $div ((y number) (x tensor))
  (let ((result ($empty x)))
    (tensor-cinv result x)
    (tensor-mul result result y)
    result))

(defmethod $div! ((y tensor) (x number))
  (tensor-div y y x)
  y)
(defmethod $div! ((y tensor) (x tensor))
  (tensor-cdiv y y x)
  y)
(defmethod $div! ((y number) (x number)) (/ y x))

(defmethod $addmul ((z tensor) (x tensor) (y tensor) &optional (α 1))
  (let ((result ($empty z)))
    (tensor-add-cmul result z α x y)
    result))

(defmethod $addmul! ((z tensor) (x tensor) (y tensor) &optional (α 1))
  (tensor-add-cmul z z α x y)
  z)

(defmethod $adddiv ((z tensor) (x tensor) (y tensor) &optional (α 1))
  (let ((result ($empty z)))
    (tensor-add-cdiv result z α x y)
    result))

(defmethod $adddiv! ((z tensor) (x tensor) (y tensor) &optional (α 1))
  (tensor-add-cdiv z z α x y)
  z)

(defmethod $fmod ((tensor tensor) (value number))
  (let ((result ($empty tensor)))
    (tensor-fmod result tensor value)
    result))
(defmethod $fmod! ((tensor tensor) (value number))
  (tensor-fmod tensor tensor value)
  tensor)

(defmethod $fmod ((tensor tensor) (value tensor))
  (let ((result ($empty tensor)))
    (tensor-cfmod result tensor value)
    result))
(defmethod $fmod! ((tensor tensor) (value tensor))
  (tensor-cfmod tensor tensor value)
  tensor)

(defmethod $rem ((tensor tensor) (value number))
  (let ((result ($empty tensor)))
    (tensor-mod result tensor value)
    result))
(defmethod $rem! ((tensor tensor) (value number))
  (tensor-mod tensor tensor value)
  tensor)

(defmethod $rem ((tensor tensor) (value tensor))
  (let ((result ($empty tensor)))
    (tensor-cmod result tensor value)
    result))
(defmethod $rem! ((tensor tensor) (value tensor))
  (tensor-cmod tensor tensor value)
  tensor)

(defmethod $dot ((x tensor) (y tensor)) (tensor-dot x y))
(defmethod $dot ((x tensor) (y number)) (tensor-dot x ($fill! ($one x) y)))
(defmethod $dot ((x number) (y tensor)) ($dot y x))
(defmethod $dot ((x number) (y number)) (* x y))

(defmethod $addmv ((x tensor) (m tensor) (v tensor) &optional (α 1) (β 1))
  (let ((result ($empty x)))
    ($resize! result x)
    (tensor-add-mv result β x α m v)
    result))

(defmethod $addmv! ((x tensor) (m tensor) (v tensor) &optional (α 1) (β 1))
  (tensor-add-mv x β x α m v)
  x)

(defmethod $gemv ((α number ) (m tensor ) (x tensor) (β number ) (y tensor))
  (let ((result ($empty y)))
    ($resize! result y)
    (tensor-add-mv result β y α m x)
    result))

(defmethod $gemv! ((α number ) (m tensor ) (x tensor) (β number ) (y tensor))
  (tensor-add-mv y β y α m x)
  y)

(defmethod $ger ((α number) (x tensor) (y tensor) (m tensor))
  (let ((result ($empty m)))
    ($resize! result m)
    (tensor-add-r result 1 m α x y)
    result))

(defmethod $ger! ((α number) (x tensor) (y tensor) (m tensor))
  (tensor-add-r m 1 m α x y)
  m)

(defmethod $addr ((m tensor) (x tensor) (y tensor) &optional (α 1) (β 1))
  (let ((result ($empty m)))
    ($resize! result m)
    (tensor-add-r result β m α x y)
    result))

(defmethod $addr! ((m tensor) (x tensor) (y tensor) &optional (α 1) (β 1))
  (tensor-add-r m β m α x y)
  m)

(defmethod $gemm ((α number) (x tensor) (y tensor) (β number) (z tensor))
  (let ((result ($empty z)))
    ($resize! result z)
    (tensor-add-mm result β z α x y)
    result))

(defmethod $gemm! ((α number) (x tensor) (y tensor) (β number) (z tensor))
  (tensor-add-mm z β z α x y)
  z)

(defmethod $addmm ((z tensor) (x tensor) (y tensor) &optional (α 1) (β 1))
  (let ((result ($empty z)))
    ($resize! result z)
    (tensor-add-mm result β z α x y)
    result))

(defmethod $addmm! ((z tensor) (x tensor) (y tensor) &optional (α 1) (β 1))
  (tensor-add-mm z β z α x y)
  z)

(defmethod $addbmm ((z tensor) (bx tensor) (by tensor) &optional (α 1) (β 1))
  (let ((result ($empty z)))
    ($resize! result z)
    (tensor-add-bmm result β z α bx by)
    result))

(defmethod $addbmm! ((z tensor) (bx tensor) (by tensor) &optional (α 1) (β 1))
  (tensor-add-bmm z β z α bx by)
  z)

(defmethod $baddbmm ((bz tensor) (bx tensor) (by tensor) &optional (α 1) (β 1))
  (let ((result ($empty bz)))
    ($resize! result bz)
    (tensor-badd-bmm result β bz α bx by)
    result))

(defmethod $baddbmm! ((bz tensor) (bx tensor) (by tensor) &optional (α 1) (β 1))
  (tensor-badd-bmm bz β bz α bx by)
  bz)

(defmethod $vv ((x tensor) (y tensor))
  (let ((result (-> ($empty x) ($resize! (list ($count x) ($count y))))))
    ($addr! result x y 1 0)
    result))
(defmethod $vv ((x number) (y tensor))
  ($mul x y))
(defmethod $vv ((x tensor) (y number))
  ($mul x y))

(defmethod $vv! ((m tensor) (x tensor) (y tensor))
  ($resize! m (list ($count x) ($count y)))
  ($addr! m x y 1 0)
  m)

(defmethod $mv ((m tensor) (v tensor))
  (let ((result (-> ($empty m) ($resize! (list ($size m 0))))))
    ($addmv! result m v 1 0)
    result))

(defmethod $mv! ((x tensor) (m tensor) (v tensor))
  ($resize! x (list ($size m 0)))
  ($addmv! x m v 1 0)
  x)

(defmethod $mm ((x tensor) (y tensor))
  (let ((result (-> ($empty x) ($resize! (list ($size x 0) ($size y 1))))))
    ($addmm! result x y 1 0)
    result))
(defmethod $mm ((x number) (y tensor))
  ($mul x y))
(defmethod $mm ((x tensor) (y number))
  ($mul x y))

(defmethod $mm! ((z tensor) (x tensor) (y tensor))
  ($resize! z (list ($size x 0) ($size y 1)))
  ($addmm! z x y 1 0)
  z)

(defmethod $bmm ((bx tensor) (by tensor))
  (let ((result (-> ($empty bx) ($resize! (list ($size bx 0) ($size bx 1) ($size by 2))))))
    ($baddbmm! result bx by 1 0)
    result))

(defmethod $bmm! ((bz tensor) (bx tensor) (by tensor))
  ($resize! bz (list ($size bx 0) ($size bx 1) ($size by 2)))
  ($baddbmm! bz bx by 1 0)
  bz)

(defun $+ (&rest args)
  "Returns + of arguments."
  (cond ((null args) 0)
        ((eq 1 ($count args)) ($0 args))
        (t (reduce #'$add args))))

(defun $- (&rest args)
  "Returns - of arguments."
  (cond ((null args) (error "invalid number of arguments: 0"))
        ((eq 1 ($count args)) ($neg ($0 args)))
        (t (reduce #'$sub args))))

(defun $* (&rest args)
  "Returns * of arguments."
  (cond ((null args) 1)
        ((eq 1 ($count args)) ($0 args))
        (t (reduce #'$mul args))))

(defun $/ (&rest args)
  "Returns / of arguments."
  (cond ((null args) (error "invalid number of arguments: 0"))
        ((eq 1 ($count args)) ($cinv ($0 args)))
        (t (reduce #'$div args))))

(defgeneric $mml (x y))

(defmethod $mml ((x tensor) (y tensor))
  (cond ((and (eq 1 ($ndim x)) (eq 1 ($ndim y))) ($dot x y))
        ((and (eq 2 ($ndim x)) (eq 1 ($ndim y))) ($mv x y))
        ((and (eq 2 ($ndim x)) (eq 2 ($ndim y))) ($mm x y))
        ((and (eq 3 ($ndim x)) (eq 3 ($ndim y))) ($bmm x y))))
(defmethod $mml ((x tensor) (y number)) ($mul x y))
(defmethod $mml ((x number) (y number)) (* x y))
(defmethod $mml ((x number) (y tensor)) ($mul x y))

(defun $@ (&rest args)
  "Returns dot of arguments."
  (cond ((null args) 1)
        ((eq 1 ($count args)) ($0 args))
        (t (reduce #'$mml args))))

(defmethod $xx ((x tensor) (y tensor) &optional dimension)
  (let ((result ($empty x))
        (dimension (or dimension
                       (loop :for i :from 0 :below ($ndim x)
                             :when (eq 3 ($size x i))
                               :return i))))
    (when dimension
      (tensor-cross result x y dimension)
      result)))

(defmethod $xx! ((z tensor) (x tensor) (y tensor) &optional dimension)
  (let ((dimension (or dimension
                       (loop :for i :from 0 :below ($ndim x)
                             :when (eq 3 ($size x i))
                               :return i))))
    (when dimension
      (tensor-cross z x y dimension)
      z)))

(defmethod $cumprd ((x tensor) &optional dimension)
  (let ((dimension (or dimension (1- ($ndim x))))
        (result ($empty x)))
    (tensor-cum-prd result x dimension)
    result))

(defmethod $cumprd! ((y tensor) (x tensor) &optional dimension)
  (let ((dimension (or dimension (1- ($ndim x)))))
    (tensor-cum-prd y x dimension)
    y))

(defmethod $cumsum ((x tensor) &optional (dimension 0))
  (let ((result ($empty x)))
    (tensor-cum-sum result x dimension)
    result))

(defmethod $cumsum! ((y tensor) (x tensor) &optional (dimension 0))
  (tensor-cum-sum y x dimension)
  y)

(defmethod $max* ((x tensor) &optional (dimension -1))
  (if (< dimension 0)
      (tensor-max-all x)
      (let ((indices (tensor.long))
            (vals ($empty x)))
        (tensor-max vals indices x dimension t)
        (list vals indices))))

(defmethod $max ((x tensor) &optional (dimension -1))
  (if (< dimension 0)
      (tensor-max-all x)
      (let ((indices (tensor.long))
            (vals ($empty x)))
        (tensor-max vals indices x dimension t)
        vals)))

(defmethod $max! ((vals tensor) (indices tensor.long) (x tensor) &optional (dimension 0))
  (tensor-max vals indices x dimension t)
  (list vals indices))

(defmethod $min* ((x tensor) &optional (dimension -1))
  (if (< dimension 0)
      (tensor-min-all x)
      (let ((indices (tensor.long))
            (vals ($empty x)))
        (tensor-min vals indices x dimension t)
        (list vals indices))))

(defmethod $min ((x tensor) &optional (dimension -1))
  (if (< dimension 0)
      (tensor-min-all x)
      (let ((indices (tensor.long))
            (vals ($empty x)))
        (tensor-min vals indices x dimension t)
        vals)))

(defmethod $min! ((vals tensor) (indices tensor.long) (x tensor) &optional (dimension 0))
  (tensor-min vals indices x dimension t)
  (list vals indices))

(defmethod $mean ((x tensor) &optional (dimension -1))
  (if (< dimension 0)
      (tensor-mean-all x)
      (let ((vals ($empty x)))
        (tensor-mean vals x dimension t)
        vals)))

(defmethod $mean! ((m tensor) (x tensor) &optional (dimension 0))
  (tensor-mean m x dimension t)
  m)

(defmethod $cmax ((tensor tensor) &rest tensors)
  (flet ((cmax (x y)
           (cond ((and ($tensorp x) ($tensorp y)) (tensor-cmax x x y))
                 ((and (numberp x) ($tensorp y)) (tensor-cmax y y x))
                 ((and ($tensorp x) (numberp y)) (tensor-cmax x x y))
                 ((and (numberp x) (numberp y)) (max x y)))))
    (reduce #'cmax tensors :initial-value (cmax ($clone tensor) tensor))))

(defmethod $cmax! ((tensor tensor) &rest tensors)
  (flet ((cmax (x y)
           (cond ((and ($tensorp x) ($tensorp y)) (tensor-cmax x x y))
                 ((and (numberp x) ($tensorp y)) (tensor-cmax y y x))
                 ((and ($tensorp x) (numberp y)) (tensor-cmax x x y))
                 ((and (numberp x) (numberp y)) (max x y)))))
    (reduce #'cmax tensors :initial-value tensor)))

(defmethod $cmin ((tensor tensor) &rest tensors)
  (flet ((cmin (x y)
           (cond ((and ($tensorp x) ($tensorp y)) (tensor-cmin x x y))
                 ((and (numberp x) ($tensorp y)) (tensor-cmin y y x))
                 ((and ($tensorp x) (numberp y)) (tensor-cmin x x y))
                 ((and (numberp x) (numberp y)) (max x y)))))
    (reduce #'cmin tensors :initial-value (cmin ($clone tensor) tensor))))

(defmethod $cmin! ((tensor tensor) &rest tensors)
  (flet ((cmin (x y)
           (cond ((and ($tensorp x) ($tensorp y)) (tensor-cmin x x y))
                 ((and (numberp x) ($tensorp y)) (tensor-cmin y y x))
                 ((and ($tensorp x) (numberp y)) (tensor-cmin x x y))
                 ((and (numberp x) (numberp y)) (max x y)))))
    (reduce #'cmin tensors :initial-value tensor)))

(defmethod $median ((x tensor) &optional (dimension -1))
  (if (< dimension 0)
      (tensor-median-all x)
      (let ((indices (tensor.long))
            (vals ($empty x)))
        (tensor-median vals indices x dimension nil)
        (list vals indices))))

(defmethod $median! ((vals tensor) (indices tensor.long) (x tensor) &optional (dimension 0))
  (tensor-median vals indices x dimension nil)
  (list vals indices))

(defmethod $mode ((x tensor) &optional dimension)
  (let ((dimension (or dimension (1- ($ndim x))))
        (indices (tensor.long))
        (vals ($empty x)))
    (tensor-mode vals indices x dimension nil)
    (list vals indices)))

(defmethod $mode! ((vals tensor) (indices tensor.long) (x tensor) &optional (dimension 0))
  (tensor-mode vals indices x dimension nil)
  (list vals indices))

(defmethod $kth ((x tensor) k &optional dimension)
  (let ((dimension (or dimension (1- ($ndim x))))
        (vals ($empty x))
        (indices (tensor.long)))
    (tensor-kth-value vals indices x k dimension nil)
    (list vals indices)))

(defmethod $kth! ((vals tensor) (indices tensor.long) (x tensor) k &optional dimension)
  (let ((dimension (or dimension (1- ($ndim x)))))
    (tensor-kth-value vals indices x k dimension nil)
    (list vals indices)))

(defmethod $topk ((x tensor) k &optional dimension descendingp sortp)
  (let ((dimension (or dimension (1- ($ndim x))))
        (vals ($empty x))
        (indices (tensor.long)))
    (tensor-top-k vals indices x k dimension descendingp sortp)
    (list vals indices)))

(defmethod $topk! ((vals tensor) (indices tensor.long) (x tensor) k
                   &optional dimension descendingp sortp)
  (let ((dimension (or dimension (1- ($ndim x)))))
    (tensor-top-k vals indices x k dimension descendingp sortp)
    (list vals indices)))

(defmethod $sort ((x tensor) &optional dimension descendingp)
  (let ((dimension (or dimension (1- ($ndim x))))
        (vals ($empty x))
        (indices (tensor.long)))
    (tensor-sort vals indices x dimension descendingp)
    (list vals indices)))

(defmethod $sort! ((vals tensor) (indices tensor.long) (x tensor) &optional dim descendingp)
  (let ((dimension (or dim (1- ($ndim x)))))
    (tensor-sort vals indices x dimension descendingp)
    (list vals indices)))

(defmethod $prd ((x tensor) &optional (dimension -1))
  (if (< dimension 0)
      (tensor-prd-all x)
      (let ((result ($empty x)))
        (tensor-prd result x dimension t)
        result)))

(defmethod $prd! ((z tensor) (x tensor) &optional (dimension 0))
  (tensor-prd z x dimension t)
  z)

(defmethod $sum ((x tensor) &optional (dimension -1))
  (if (< dimension 0)
      (tensor-sum-all x)
      (let ((result ($empty x)))
        (tensor-sum result x dimension t)
        result)))

(defmethod $sum ((x number) &optional (dimension -1))
  (declare (ignore dimension))
  x)

(defmethod $sum ((xs list) &optional (dimension -1))
  (if (< dimension 0)
      (reduce #'+ xs)
      (error "list does not support dimension")))

(defmethod $sum! ((z tensor) (x tensor) &optional (dimension 0))
  (tensor-sum z x dimension t)
  z)

(defmethod $sd ((x tensor) &optional (dimension -1) biased)
  (if (< dimension 0)
      (tensor-sd-all x biased)
      (let ((result ($empty x)))
        (tensor-sd result x dimension t biased)
        result)))

(defmethod $sd! ((z tensor) (x tensor) &optional (dimension 0) biased)
  (tensor-sd z x dimension t biased)
  z)

(defmethod $var ((x tensor) &optional (dimension -1) biased)
  (if (< dimension 0)
      (tensor-var-all x biased)
      (let ((result ($empty x)))
        (tensor-var result x dimension t biased)
        result)))

(defmethod $var! ((z tensor) (x tensor) &optional (dimension 0) biased)
  (tensor-var z x dimension t biased)
  z)

(defmethod $uniform! ((x tensor) a b)
  (tensor-uniform x a b)
  x)

(defmethod $uniform ((x tensor) a b)
  (let ((r ($resize! ($empty x) ($size x))))
    (tensor-uniform r a b)
    r))

(defmethod $normal! ((x tensor) m sd)
  (tensor-normal x m sd)
  x)

(defmethod $normal ((x tensor) m sd)
  (let ((r ($resize! ($empty x) ($size x))))
    (tensor-normal r m sd)
    r))

(defmethod $exponential! ((x tensor) lam)
  (tensor-exponential x lam)
  x)

(defmethod $exponential ((x tensor) lam)
  (let ((r ($resize! ($empty x) ($size x))))
    (tensor-exponential r lam)
    r))

(defmethod $bernoulli! ((x tensor) p)
  (tensor-bernoulli x p)
  x)

(defmethod $bernoulli ((x tensor) p)
  (let ((r ($resize! ($empty x) ($size x))))
    (tensor-bernoulli r p)
    r))

(defmethod $binomial! ((x tensor) n p)
  (tensor-binomial x n p)
  x)

(defmethod $binomial ((x tensor) n p)
  (let ((r ($resize! ($empty x) ($size x))))
    (tensor-binomial r n p)
    r))

(defmethod $geometric! ((x tensor) p)
  (tensor-geometric x p)
  x)

(defmethod $geometric ((x tensor) p)
  (let ((r ($resize! ($empty x) ($size x))))
    (tensor-geometric r p)
    r))

(defmethod $hypergeometric! ((x tensor) nr nb k)
  (tensor-hypergeometric x nr nb k)
  x)

(defmethod $hypergeometric ((x tensor) nr nb k)
  (let ((r ($resize! ($empty x) ($size x))))
    (tensor-hypergeometric r nr nb k)
    r))

(defmethod $beta! ((x tensor) a b)
  (tensor-rbeta x a b)
  x)

(defmethod $poisson! ((x tensor) mu)
  (tensor-poisson x mu)
  x)

(defmethod $poisson ((x tensor) mu)
  (let ((r ($resize! ($empty x) ($size x))))
    (tensor-poisson r mu)
    r))

(defmethod $beta ((x tensor) a b)
  (let ((r ($resize! ($empty x) ($size x))))
    (tensor-rbeta r a b)
    r))

(defmethod $beta! ((x tensor) a b)
  (tensor-rbeta x a b)
  x)

(defmethod $gamma! ((x tensor) shape scale)
  (tensor-rgamma x shape scale)
  x)

(defmethod $gamma ((x tensor) shape scale)
  (let ((r ($resize! ($empty x) ($size x))))
    (tensor-rgamma r shape scale)
    r))

(defmethod $chisq! ((x tensor) df) ($gamma! x (/ df 2.0) 2.0))
(defmethod $chisq ((x tensor) df) ($gamma x (/ df 2.0) 2.0))

(defmethod $fdist! ((x tensor) n1 n2)
  (let ((x2 ($div ($chisq x n2) n2))
        (x1 ($div! ($chisq! x n1) n1)))
    ($div! x1 x2)))

(defmethod $fdist ((x tensor) n1 n2)
  (let ((x2 ($div ($chisq x n2) n2))
        (x1 ($div ($chisq x n1) n1)))
    ($div! x1 x2)))

(defmethod $norm ((x tensor) &optional (p 2) (dimension -1))
  (if (< dimension 0)
      (tensor-norm-all x p)
      (let ((result ($empty x)))
        (tensor-norm result x p dimension nil)
        result)))

(defmethod $norm! ((z tensor) (x tensor) &optional (p 2) (dimension 0))
  (tensor-norm z x p dimension nil)
  z)

(defmethod $renorm ((x tensor) p dimension max)
  (let ((result ($empty x)))
    (tensor-renorm result x p dimension max)
    result))

(defmethod $renorm! ((z tensor) (x tensor) p dimension max)
  (tensor-renorm z x p dimension max)
  z)

(defmethod $dist (x y &optional (p 2)) (tensor-dist x y p))

(defmethod $trace ((x tensor)) (tensor-trace x))

(defmethod $conv2 ((x tensor) (k tensor) &optional (type :valid))
  (let ((result ($empty x))
        (type (if (eq type :valid) "V" "F"))
        (xc "C"))
    (cond ((and (eq 2 ($ndim x)) (eq 2 ($ndim k)))
           (tensor-conv-2d-mul result 0 1 x k 1 1 type xc))
          ((and (eq 3 ($ndim x)) (eq 3 ($ndim k)))
           (tensor-conv-2d-cmul result 0 1 x k 1 1 type xc))
          ((and (eq 3 ($ndim x)) (eq 4 ($ndim k)))
           (tensor-conv-2d-mv result 0 1 x k 1 1 type xc)))
    result))

(defmethod $conv2! ((r tensor) (x tensor) (k tensor) &optional (type :valid))
  (let ((type (if (eq type :valid) "V" "F"))
        (xc "C"))
    (cond ((and (eq 2 ($ndim x)) (eq 2 ($ndim k)))
           (tensor-conv-2d-mul r 0 1 x k 1 1 type xc))
          ((and (eq 3 ($ndim x)) (eq 3 ($ndim k)))
           (tensor-conv-2d-cmul r 0 1 x k 1 1 type xc))
          ((and (eq 3 ($ndim x)) (eq 4 ($ndim k)))
           (tensor-conv-2d-mv r 0 1 x k 1 1 type xc)))
    r))

(defmethod $xcorr2 ((x tensor) (k tensor) &optional (type :valid))
  (let ((result ($empty x))
        (type (if (eq type :valid) "V" "F"))
        (xc "X"))
    (cond ((and (eq 2 ($ndim x)) (eq 2 ($ndim k)))
           (tensor-conv-2d-mul result 0 1 x k 1 1 type xc))
          ((and (eq 3 ($ndim x)) (eq 3 ($ndim k)))
           (tensor-conv-2d-cmul result 0 1 x k 1 1 type xc))
          ((and (eq 3 ($ndim x)) (eq 4 ($ndim k)))
           (tensor-conv-2d-mv result 0 1 x k 1 1 type xc)))
    result))

(defmethod $xcorr2! ((r tensor) (x tensor) (k tensor) &optional (type :valid))
  (let ((type (if (eq type :valid) "V" "F"))
        (xc "X"))
    (cond ((and (eq 2 ($ndim x)) (eq 2 ($ndim k)))
           (tensor-conv-2d-mul r 0 1 x k 1 1 type xc))
          ((and (eq 3 ($ndim x)) (eq 3 ($ndim k)))
           (tensor-conv-2d-cmul r 0 1 x k 1 1 type xc))
          ((and (eq 3 ($ndim x)) (eq 4 ($ndim k)))
           (tensor-conv-2d-mv r 0 1 x k 1 1 type xc)))
    r))

(defmethod $conv3 ((x tensor) (k tensor) &optional (type :valid))
  (let ((result ($empty x))
        (type (if (eq type :valid) "V" "F"))
        (xc "C"))
    (cond ((and (eq 3 ($ndim x)) (eq 3 ($ndim k)))
           (tensor-conv-3d-mul result 0 1 x k 1 1 1 type xc))
          ((and (eq 4 ($ndim x)) (eq 4 ($ndim k)))
           (tensor-conv-3d-cmul result 0 1 x k 1 1 1 type xc))
          ((and (eq 4 ($ndim x)) (eq 5 ($ndim k)))
           (tensor-conv-3d-mv result 0 1 x k 1 1 1 type xc)))
    result))

(defmethod $conv3! ((r tensor) (x tensor) (k tensor) &optional (type :valid))
  (let ((type (if (eq type :valid) "V" "F"))
        (xc "C"))
    (cond ((and (eq 3 ($ndim x)) (eq 3 ($ndim k)))
           (tensor-conv-3d-mul r 0 1 x k 1 1 1 type xc))
          ((and (eq 4 ($ndim x)) (eq 4 ($ndim k)))
           (tensor-conv-3d-cmul r 0 1 x k 1 1 1 type xc))
          ((and (eq 4 ($ndim x)) (eq 5 ($ndim k)))
           (tensor-conv-3d-mv r 0 1 x k 1 1 1 type xc)))
    r))

(defmethod $xcorr3 ((x tensor) (k tensor) &optional (type :valid))
  (let ((result ($empty x))
        (type (if (eq type :valid) "V" "F"))
        (xc "X"))
    (cond ((and (eq 3 ($ndim x)) (eq 3 ($ndim k)))
           (tensor-conv-3d-mul result 0 1 x k 1 1 1 type xc))
          ((and (eq 4 ($ndim x)) (eq 4 ($ndim k)))
           (tensor-conv-3d-cmul result 0 1 x k 1 1 1 type xc))
          ((and (eq 4 ($ndim x)) (eq 5 ($ndim k)))
           (tensor-conv-3d-mv result 0 1 x k 1 1 1 type xc)))
    result))

(defmethod $xcorr3! ((r tensor) (x tensor) (k tensor) &optional (type :valid))
  (let ((type (if (eq type :valid) "V" "F"))
        (xc "X"))
    (cond ((and (eq 3 ($ndim x)) (eq 3 ($ndim k)))
           (tensor-conv-3d-mul r 0 1 x k 1 1 1 type xc))
          ((and (eq 4 ($ndim x)) (eq 4 ($ndim k)))
           (tensor-conv-3d-cmul r 0 1 x k 1 1 1 type xc))
          ((and (eq 4 ($ndim x)) (eq 5 ($ndim k)))
           (tensor-conv-3d-mv r 0 1 x k 1 1 1 type xc)))
    r))

(defmethod $gesv ((b tensor) (a tensor))
  (let ((x ($empty a))
        (lu ($empty a)))
    (tensor-gesv x lu b a)
    (list x lu)))

(defmethod $gesv! ((x tensor) (lu tensor) (b tensor) (a tensor))
  (tensor-gesv x lu b a)
  (list x lu))

(defmethod $trtrs ((b tensor) (a tensor) &optional (up t) trans unit-diag)
  (let ((x ($empty a))
        (tm ($empty a)))
    (tensor-trtrs x tm b a up trans unit-diag)
    x))

(defmethod $trtrs! ((x tensor) (b tensor) (a tensor) &optional (up t) trans unit-diag)
  (let ((tm ($empty a)))
    (tensor-trtrs x tm b a up trans unit-diag)
    x))

(defmethod $potrf ((a tensor) &optional (up t))
  (let ((ch ($empty a)))
    (tensor-potrf ch a up)
    ch))

(defmethod $potrf! ((ch tensor) (a tensor) &optional (up t))
  (tensor-potrf ch a up)
  ch)

(defun $cholesky (a &optional (up t))
  ($potrf a up))

(defun $cholesky! (a &optional (up t))
  ($potrf! a up))

(defmethod $pstrf ((a tensor) &optional (up t))
  (let ((ch ($empty a))
        (piv (tensor.int)))
    (tensor-pstrf ch piv a up -1D0)
    ($fmap! (lambda (v) (1- v)) piv)
    (list ch piv)))

(defmethod $pstrf! ((ch tensor) (piv tensor.int) (a tensor) &optional (up t))
  (tensor-pstrf ch piv a up -1D0)
  ($fmap! (lambda (v) (1- v)) piv)
  (list ch piv))

(defmethod $potrs ((b tensor) (ch tensor) &optional (up t))
  (let ((x ($empty ch)))
    (tensor-potrs x b ch up)
    x))

(defmethod $potrs! ((x tensor) (b tensor) (ch tensor) &optional (up t))
  (tensor-potrs x b ch up)
  x)

(defmethod $potri ((ch tensor) &optional (up t))
  (let ((inv ($empty ch)))
    (tensor-potri inv ch up)
    inv))

(defmethod $potri! ((inv tensor) (ch tensor) &optional (up t))
  (tensor-potri inv ch up)
  inv)

(defmethod $gels ((b tensor) (a tensor))
  (let ((x ($empty a))
        (f ($empty a)))
    (tensor-gels x f b a)
    x))

(defmethod $gels! ((x tensor) (b tensor) (a tensor))
  (let ((f ($empty a)))
    (tensor-gels x f b a)
    x))

(defmethod $syev ((a tensor) &optional all (up t))
  (let ((e ($empty a))
        (v ($empty a)))
    (tensor-syev e v a all up)
    (list e v)))

(defmethod $syev! ((e tensor) (v tensor) (a tensor) &optional all (up t))
  (tensor-syev e v a all up)
  (list e v))

(defmethod $ev ((a tensor) &optional all)
  (let ((e ($empty a))
        (v ($empty a)))
    (tensor-geev e v a all)
    (list e v)))

(defmethod $ev! ((e tensor) (v tensor) (a tensor) &optional all)
  (tensor-geev e v a all)
  (list e v))

(defmethod $svd ((a tensor) &optional all)
  (let ((u ($empty a))
        (s ($empty a))
        (v ($empty a)))
    (tensor-gesvd u s v a all)
    (list u s v)))

(defmethod $svd! ((u tensor) (s tensor) (v tensor) (a tensor) &optional all)
  (tensor-gesvd u s v a all)
  (list u s v))

(defmethod $rsvd ((m tensor) &optional k)
  (let* ((sz ($size m))
         (nr ($ sz 0))
         (nc ($ sz 1))
         (k (if k k (min nr nc)))
         (transposed nil))
    (when (< nr nc)
      (setf m ($transpose m)
            transposed T))
    (let* ((rm (rndn ($size m 1) k))
           (qr ($qr ($@ m rm)))
           (q (car qr))
           (sm ($@ ($transpose q) m))
           (usv ($svd sm nil))
           (uh ($ usv 0))
           (s ($ usv 1))
           (v ($ usv 2))
           (u ($@ q uh)))
      (if transposed
          (list ($transpose v) ($transpose s) ($transpose u))
          (list u s v)))))

(defmethod $inverse ((a tensor))
  (let ((r ($empty a)))
    (tensor-getri r a)
    r))

(defmethod $inverse! ((r tensor) (a tensor))
  (tensor-getri r a)
  r)

(defmethod $qr ((x tensor))
  (let ((q ($empty x))
        (r ($empty x)))
    (tensor-qr q r x)
    (list q r)))

(defmethod $qr! ((q tensor) (r tensor) (x tensor))
  (tensor-qr q r x)
  (list q r))

(defmethod $multinomial ((probdist tensor.float) n)
  (let ((result (tensor.long)))
    (th-float-tensor-multinomial ($handle result)
                                 ($handle *generator*)
                                 ($handle probdist)
                                 n
                                 1)
    result))

(defmethod $multinomial ((probdist tensor.double) n)
  (let ((result (tensor.long)))
    (th-double-tensor-multinomial ($handle result)
                                  ($handle *generator*)
                                  ($handle probdist)
                                  n
                                  1)
    result))

(defgeneric $broadcast (constant matrix))

(defgeneric $krows (vector n))
(defgeneric $kcols (vector n))

(defmethod $krows ((vector tensor) n) ($vv (ones n) vector))
(defmethod $kcols ((vector tensor) n) ($vv vector (ones n)))

(defmethod $broadcast ((vector tensor) (matrix tensor))
  (cond ((eq 1 ($ndim vector)) (let ((nv ($count vector))
                                     (sz ($size matrix)))
                                 (cond ((eq nv ($ sz 1)) ($krows vector ($ sz 0)))
                                       ((eq nv ($ sz 0)) ($kcols vector ($ sz 1)))
                                       (t (error "cannot broadcast automatically")))))
        ((and (eq 2 ($ndim vector)) (or (eq 1 ($size vector 0)) (eq 1 ($size vector 1))))
         (let ((nv ($count vector))
               (sz ($size matrix)))
           (cond ((eq nv ($ sz 1)) ($krows ($reshape vector nv) ($ sz 0)))
                 ((eq nv ($ sz 0)) ($kcols ($reshape vector nv) ($ sz 1)))
                 (t (error "cannot broadcast automatically")))))
        ((equal ($size vector) ($size matrix)) vector)))

(defmethod $broadcast ((c number) (m tensor)) ($mul! ($one m) c))

(defgeneric $clear (tensor) (:documentation "new tensor allocated as given one."))

(defmethod $clear ((tensor tensor))
  (let* ((cls (type-of tensor))
         (instance (make-instance cls)))
    (allocate-tensor instance ($size tensor))
    instance))

(defmethod $mean ((xs list) &optional (dimension -1))
  ($mean (tensor xs) dimension))

(defmethod $sd ((xs list) &optional (dimension -1) biased)
  ($sd (tensor xs) dimension biased))

(defmethod $median ((xs list) &optional (dimension -1))
  ($median (tensor xs) dimension))

(defmethod $mode ((xs list) &optional (dimension 0))
  ($mode (tensor xs) dimension))

(defmethod $percentile ((x tensor) q)
  (let* ((n ($count x))
         (k (1+ (round (* (- n 1) q 0.01D0)))))
    (car ($kth ($view x n) k 0))))

(defmethod $percentile ((xs list) q)
  ($percentile (tensor xs) q))

(defmethod $cv ((x tensor))
  (* 100D0 (/ ($sd x) ($mean x))))

(defmethod $cv ((xs list)) ($cv (tensor xs)))

(defmethod $se ((x tensor)) (/ ($sd x) (sqrt ($count x))))
(defmethod $se ((xs list)) ($se (tensor xs)))
