(in-package :th.pp)

(defun nuts/build-base (posterior cs ms u v step)
  (let* ((dmax 1000)
         (lfres (hmc/leapfrog cs ms posterior 1 (* v step)))
         (ncs ($0 lfres))
         (nms ($1 lfres))
         (ne (let ((l (funcall posterior (mapcar #'$data ncs)))
                   (k (hmc/kinetic nms)))
               (when (and l k) ($sub l k))))
         (nn (if (and ne (<= u (exp ne))) 1 0))
         (ns (if (and ne (> u 0) (> ne (- (log u) dmax))) 1 0)))
    (list ncs nms ncs nms ncs nn ns)))

(defun nuts/cs- (record) ($0 record))
(defun nuts/ms- (record) ($1 record))
(defun nuts/cs+ (record) ($2 record))
(defun nuts/ms+ (record) ($3 record))
(defun nuts/ncs (record) ($4 record))
(defun nuts/n (record) ($5 record))
(defun nuts/s (record) ($6 record))

(defun nuts/updated-s (nns ncs- nms- ncs+ nms+)
  (let ((vs (let ((v1 0)
                  (v2 0))
              (loop :for c+ :in ncs+
                    :for c- :in ncs-
                    :for dc = ($sub ($data c+) ($data c-))
                    :for i :from 0
                    :do (setf v1 ($add v1 ($dot dc ($ nms- i)))
                              v2 ($add v2 ($dot dc ($ nms+ i)))))
              (list v1 v2))))
    (* nns (if (>= ($0 vs) 0) 1 0) (if (>= ($1 vs) 0) 1 0))))

(defun nuts/build-tree (posterior cs ms u v j step)
  (let ((cs (mapcar #'$clone cs)))
    (if (= j 0)
        (nuts/build-base posterior cs ms u v step)
        (let* ((res (nuts/build-tree posterior cs ms u v (- j 1) step))
               (ncs- (nuts/cs- res))
               (nms- (nuts/ms- res))
               (ncs+ (nuts/cs+ res))
               (nms+ (nuts/ms+ res))
               (ncs (nuts/ncs res))
               (nncs ncs)
               (nn (nuts/n res))
               (nnn nn)
               (ns (nuts/s res))
               (nns ns))
          (when (= ns 1)
            (if (= v -1)
                (let ((nres (nuts/build-tree posterior ncs- nms- u v (- j 1) step)))
                  (setf ncs- (nuts/cs- nres)
                        nms- (nuts/ms- nres)
                        nncs (nuts/ncs nres)
                        nnn (nuts/n nres)
                        nns (nuts/s nres)))
                (let ((nres (nuts/build-tree posterior ncs+ nms+ u v (- j 1) step)))
                  (setf ncs+ (nuts/cs+ nres)
                        nms+ (nuts/ms+ nres)
                        nncs (nuts/ncs nres)
                        nnn (nuts/n nres)
                        nns (nuts/s nres))))
            (when (and (> nn 0) (> nnn 0) (>= (/ nnn (+ nn nnn)) (random 1.0)))
              (setf ncs nncs))
            (setf ns (nuts/updated-s nns ncs- nms- ncs+ nms+))
            (setf nn (+ nn nnn)))
          (list ncs- nms- ncs+ nms+ ncs nn ns)))))

(defun mcmc/nuts (parameters posterior-function
                  &key (iterations 2000) (tune-steps 100) (burn-in 1000) (thin 1))
  (labels ((posterior (vs) (apply posterior-function vs))
           (vals (parameters) (mapcar #'$data parameters)))
    (let ((nsize (+ burn-in iterations))
          (l (posterior (vals parameters)))
          (np ($count parameters))
          (m 0)
          (sd 1)
          (step-size-info (find-reasonable-epsilon parameters posterior-function)))
      (when l
        (let ((proposals (mapcar #'r/proposal parameters))
              (cs ($1 step-size-info))
              (traces (mcmc/traces np :burn-in burn-in :thin thin))
              (maxprob l)
              (naccepted 0)
              (nrejected 0)
              (step ($0 step-size-info))
              (fstep ($0 step-size-info))
              (sizer (hmc/step-sizer ($0 step-size-info)))
              (tuning-done nil)
              (failed nil))
          (prn (format nil "[MCMC/NUTS: TUNING..."))
          (loop :for trace :in traces
                :for candidate :in cs
                :do (trace/map! trace ($data candidate)))
          (loop :repeat nsize
                :for iter :from 1
                :for burning = (<= iter burn-in)
                :for tuneable = (zerop (rem iter tune-steps))
                :for ms = (mapcar (lambda (c) (hmc/momentum c m sd)) cs)
                :for k = (hmc/kinetic ms)
                :for e = ($sub l k)
                :for u = (random/uniform 0 (exp e))
                :while (not failed)
                :do (let ((tune (and (> iter 1) burning tuneable))
                          (s 1)
                          (n 1)
                          (j 0)
                          (cs- cs)
                          (cs+ cs)
                          (ms- ms)
                          (ms+ ms)
                          (ncs cs)
                          (mcs cs)
                          (nn 1)
                          (ns 1)
                          (accept nil))
                      (when tune
                        (loop :for proposal :in proposals :do (proposal/tune! proposal)))
                      (when burning
                        (let ((r (* 1D0 (/ naccepted (+ 1E-7 naccepted nrejected)))))
                          (let ((stune (hmc/update-step-sizer! sizer r)))
                            (setf fstep (car stune))
                            (setf step (car stune)))))
                      (unless burning
                        (unless tuning-done
                          (prns (format nil " DONE. SAMPLING..."))
                          (setf tuning-done T))
                        (unless (= step fstep)
                          (setf step fstep)))
                      (when tuning-done
                        (unless burning
                          (when (zerop naccepted)
                            (setf failed T))))
                      (loop :while (= s 1)
                            :for rv = (random 2)
                            :do (let ((v (if (zerop rv) -1 1)))
                                  (if (= v -1)
                                      (let ((rr- (nuts/build-tree #'posterior cs- ms- u v j step)))
                                        (setf cs- (nuts/cs- rr-)
                                              ms- (nuts/ms- rr-)
                                              ncs (nuts/ncs rr-)
                                              nn (nuts/n rr-)
                                              ns (nuts/s rr-)))
                                      (let ((rr+ (nuts/build-tree #'posterior cs+ ms+ u v j step)))
                                        (setf cs+ (nuts/cs+ rr+)
                                              ms+ (nuts/ms+ rr+)
                                              ncs (nuts/ncs rr+)
                                              nn (nuts/n rr+)
                                              ns (nuts/s rr+))))
                                  (when (= ns 1)
                                    (when (and (> n 0) (>= (/ nn n) (random 1.0)))
                                      (setf mcs ncs
                                            accept T)))
                                  (setf n (+ n nn)
                                        s (nuts/updated-s ns cs- ms- cs+ ms+)
                                        j (+ 1 j))))
                      (when accept
                        (incf naccepted)
                        (loop :for tr :in traces
                              :for c :in mcs
                              :do (when (r/continuousp c)
                                    (trace/push! ($data c) tr)))
                        (setf cs mcs)
                        (setf l (posterior (vals cs)))
                        (when (> l maxprob)
                          (setf maxprob l)
                          (loop :for trace :in traces
                                :for candidate :in cs
                                :do (when (r/continuousp candidate)
                                      (trace/map! trace ($data candidate))))))
                      (unless accept
                        (incf nrejected)
                        (loop :for tr :in traces
                              :for c :in cs
                              :do (when (r/continuousp c)
                                    (trace/push! ($data c) tr))))
                      (loop :for proposal :in proposals
                            :for candidate :in cs
                            :for trace :in traces
                            :do (when (r/discretep candidate)
                                  (let* ((lhr (r/propose! candidate proposal))
                                         (nprob (posterior (vals cs)))
                                         (accepted (mh/accepted l nprob lhr)))
                                    (r/accept! candidate proposal accepted)
                                    (trace/push! ($data candidate) trace)
                                    (when accepted
                                      (setf l nprob)
                                      (when (> nprob maxprob)
                                        (setf maxprob nprob)
                                        (trace/map! trace ($data candidate)))))))))
          (if (zerop naccepted)
              (prns (format nil " FAILED]~%"))
              (prns (format nil " FINISHED]~%")))
          traces)))))
