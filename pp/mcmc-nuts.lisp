(in-package :th.pp)

(defun nuts/build-tree (cs posterior ms u v j step)
  (let ((cs (mapcar #'$clone cs))
        (dmax 1000))
    (if (= j 0)
        (let* ((lfres (leapfrog cs ms posterior 1 (* v step)))
               (ncs ($0 lfres))
               (nms ($1 lfres))
               (ne (let ((l (funcall posterior (mapcar #'$data ncs)))
                         (k (hmc/kinetic nms)))
                     (when (and l k) ($sub l k))))
               (nn (if (and ne (<= u (exp ne))) 1 0))
               (ns (if (and ne (> u 0) (> ne (- (log u) dmax))) 1 0)))
          (list ncs nms ncs nms ncs nn ns))
        (let* ((res (nuts/build-tree cs posterior ms u v (- j 1) step))
               (ncs- ($0 res))
               (nms- ($1 res))
               (ncs+ ($2 res))
               (nms+ ($3 res))
               (ncs ($4 res))
               (nncs ncs)
               (nn ($5 res))
               (nnn nn)
               (ns ($6 res))
               (nns ns))
          (when (= ns 1)
            (if (= v -1)
                (let ((nres (nuts/build-tree ncs- posterior nms- u v (- j 1) step)))
                  (setf ncs- ($0 nres)
                        nms- ($1 nres)
                        nncs ($4 nres)
                        nnn ($5 nres)
                        nns ($6 nres)))
                (let ((nres (nuts/build-tree ncs+ posterior nms+ u v (- j 1) step)))
                  (setf ncs+ ($2 nres)
                        nms+ ($3 nres)
                        nncs ($4 nres)
                        nnn ($5 nres)
                        nns ($6 nres))))
            (when (and (> nn 0) (> nnn 0) (>= (/ nnn (+ nn nnn)) (random 1.0)))
              (setf ncs nncs))
            (let ((vs (let ((v1 0)
                            (v2 0))
                        (loop :for c+ :in ncs+
                              :for c- :in ncs-
                              :for dc = ($sub ($data c+) ($data c-))
                              :for i :from 0
                              :do (setf v1 ($add v1 ($dot dc ($ nms- i)))
                                        v2 ($add v2 ($dot dc ($ nms+ i)))))
                        (list v1 v2))))
              (setf ns (* nns (if (>= ($0 vs) 0) 1 0) (if (>= ($1 vs) 0) 1 0)))
              (setf nn (+ nn nnn))))
          (list ncs- nms- ncs+ nms+ ncs nn ns)))))

(defun mcmc/nuts (parameters posterior-function
                  &key (iterations 2000) (tune-steps 100) (burn-in 1000) (thin 1))
  (labels ((posterior (vs) (apply posterior-function vs))
           (vals (parameters) (mapcar #'$data parameters)))
    (let ((nsize (+ burn-in iterations))
          (l (posterior (vals parameters)))
          (np ($count parameters))
          (m 0)
          (sd 1)
          (step-size 0.1))
      (when l
        (let ((proposals (mapcar #'r/proposal parameters))
              (cs (mapcar #'$clone parameters))
              (traces (mcmc/traces np :burn-in burn-in :thin thin))
              (maxprob l)
              (naccepted 0)
              (nrejected 0)
              (step step-size)
              (fstep step-size)
              (sizer (hmc/step-sizer step-size))
              (tuning-done nil)
              (failed nil))
          (prn (format nil "[MCMC/NUTS: TUNING..."))
          (loop :for trace :in traces
                :for candidate :in cs
                :do (trace/map! trace ($data candidate)))
          (loop :repeat nsize
                :for iter :from 1
                :for burning = (<= iter burn-in)
                :for tuneable = (zerop (rem iter tune-steps))
                :for ms = (mapcar (lambda (c) (hmc/momentum c m sd)) cs)
                :for k = (hmc/kinetic ms)
                :for e = ($sub l k)
                :for u = (random/uniform 0 (exp e))
                :while (not failed)
                :do (let ((tune (and (> iter 1) burning tuneable))
                          (s 1)
                          (n 1)
                          (j 0)
                          (cs- cs)
                          (cs+ cs)
                          (ms- ms)
                          (ms+ ms)
                          (ncs cs)
                          (mcs cs)
                          (nn 1)
                          (ns 1)
                          (accept nil))
                      (loop :while (= s 1)
                            :for rv = (random 2)
                            :do (let ((v (if (zerop rv) -1 1)))
                                  (if (= v -1)
                                      (let ((rr- (nuts/build-tree cs- #'posterior ms- u v j step)))
                                        (setf cs- ($0 rr-)
                                              ms- ($1 rr-)
                                              ncs ($4 rr-)
                                              nn ($5 rr-)
                                              ns ($6 rr-)))
                                      (let ((rr+ (nuts/build-tree cs+ #'posterior ms+ u v j step)))
                                        (setf cs+ ($2 rr+)
                                              ms+ ($3 rr+)
                                              ncs ($4 rr+)
                                              nn ($5 rr+)
                                              ns ($6 rr+))))
                                  (when (= ns 1)
                                    (when (and (> n 0) (>= (/ nn n) (random 1.0)))
                                      (setf mcs ncs
                                            accept T)))
                                  (let ((vs (let ((v1 0)
                                                  (v2 0))
                                              (loop :for c+ :in cs+
                                                    :for c- :in cs-
                                                    :for dc = ($sub ($data c+) ($data c-))
                                                    :for i :from 0
                                                    :do (setf v1 ($add v1 ($dot dc ($ ms- i)))
                                                              v2 ($add v2 ($dot dc ($ ms+ i)))))
                                              (list v1 v2))))
                                    (setf n (+ n nn)
                                          s (* ns
                                               (if (>= ($0 vs) 0) 1 0)
                                               (if (>= ($1 vs) 0) 1 0))
                                          j (+ 1 j)))))
                      (when tune
                        (loop :for proposal :in proposals :do (proposal/tune! proposal)))
                      (when burning
                        (let ((r (* 1D0 (/ naccepted (+ 1E-7 naccepted nrejected)))))
                          (let ((stune (hmc/update-step-sizer! sizer r)))
                            (setf fstep (car stune))
                            (setf step (car stune)))))
                      (unless burning
                        (unless tuning-done
                          (prns (format nil " DONE. SAMPLING..."))
                          (setf tuning-done T))
                        (unless (= step fstep)
                          (setf step fstep)))
                      (when tuning-done
                        (unless burning
                          (when (zerop naccepted)
                            (setf failed T))))
                      (when accept
                        (incf naccepted)
                        (loop :for tr :in traces
                              :for c :in mcs
                              :do (when (r/continuousp c)
                                    (trace/push! ($data c) tr)))
                        (setf cs mcs)
                        (setf l (posterior (vals cs)))
                        (when (> l maxprob)
                          (setf maxprob l)
                          (loop :for trace :in traces
                                :for candidate :in cs
                                :do (when (r/continuousp candidate)
                                      (trace/map! trace ($data candidate))))))
                      (unless accept
                        (incf nrejected)
                        (loop :for tr :in traces
                              :for c :in cs
                              :do (when (r/continuousp c)
                                    (trace/push! ($data c) tr))))
                      (loop :for proposal :in proposals
                            :for candidate :in cs
                            :for trace :in traces
                            :do (when (r/discretep candidate)
                                  (let* ((lhr (r/propose! candidate proposal))
                                         (nprob (posterior (vals cs)))
                                         (accepted (mh/accepted l nprob lhr)))
                                    (r/accept! candidate proposal accepted)
                                    (trace/push! ($data candidate) trace)
                                    (when accepted
                                      (setf l nprob)
                                      (when (> nprob maxprob)
                                        (setf maxprob nprob)
                                        (trace/map! trace ($data candidate)))))))))
          (if (zerop naccepted)
              (prns (format nil " FAILED]~%"))
              (prns (format nil " FINISHED]~%")))
          traces)))))
