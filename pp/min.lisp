(in-package :th.pp)

(defun nm/runfunc (counter function args)
  (let ((args (if (listp args) args ($list args))))
    (setf ($ counter 0) (1+ ($ counter 0)))
    (apply function args)))

(defun nm/maxsimdiff (sim)
  (loop :for k :from 1 :below ($size sim 0)
        :maximizing ($max ($abs ($sub ($ sim k) ($ sim 0))))))

(defun nm/maxfsimdiff (fsim) ($max ($abs ($sub fsim ($ fsim 0)))))

(defun nm/order (tensor ind)
  (let ((size ($size tensor)))
    ($gather tensor 0 ($expand ($transpose ind) size))))

(defun nelder-mead (function x0 &key adaptive)
  ;; XXX more discrete variable related customizations are required.
  (let* ((fatol 1E-4)
         (xatol 1E-4)
         (n ($count x0))
         (maxiter (* n 200))
         (maxfun (* n 200))
         (rho 1.0)
         (chi (if adaptive (+ 1.0 (/ 2.0 n)) 2.0))
         (psi (if adaptive (- 0.75 (/ 1.0 (* 2.0 n))) 0.5))
         (sigma (if adaptive (- 1.0 (/ 1.0 n)) 0.5))
         (nonzdelt 0.05)
         (zdelt 0.00025)
         (sim (tensor (1+ n) n))
         (fsim (tensor (1+ n)))
         (ind nil)
         (fcalls (tensor.long '(0)))
         (keep T)
         (wflag 0)
         (xts (tensor.long (loop :for k :from 0 :below ($count x0)
                                 :collect (if (integerp ($ x0 k)) 1 0)))))
    (setf ($ sim 0) x0)
    (loop :for k :from 0 :below n
          :for vt = ($ xts k)
          :for y = (tensor x0)
          :do (progn
                (if (zerop ($ y k))
                    (if (= vt 1)
                        (setf ($ y k) 1)
                        (setf ($ y k) zdelt))
                    (if (= vt 1)
                        (setf ($ y k) (if (> (abs (round (* nonzdelt ($ y k)))) 0)
                                          (round (* (+ 1 nonzdelt) ($ y k)))
                                          (+ ($ y k) (* (signum ($ y k)) 1))))
                        (setf ($ y k) (* (+ 1 nonzdelt) ($ y k)))))
                (setf ($ sim (1+ k)) y)))
    (loop :for k :from 0 :below (1+ n)
          :do (setf ($ fsim k) (nm/runfunc fcalls function ($ sim k))))
    (let ((sr ($sort fsim)))
      (setf fsim (car sr)
            ind (cadr sr)))
    (setf sim (nm/order sim ind))
    (loop :for iterations :from 1
          :while (let ((fw (< ($ fcalls 0) maxfun))
                       (iw (< iterations maxiter)))
                   (cond ((not fw) (setf wflag 1))
                         ((not iw) (setf wflag 2)))
                   (and keep fw iw))
          :for xbar = ($squeeze ($mean ($subview sim 0 (1- ($size sim 0))) 0))
          :for xr = ($sub ($mul (1+ rho) xbar) ($mul rho ($ sim (1- ($size sim 0)))))
          :do (let ((fxr (nm/runfunc fcalls function xr))
                    (doshrink 0))
                (if (< fxr ($ fsim 0))
                    (let* ((xe ($sub ($mul (1+ (* rho chi)) xbar)
                                     ($mul (* rho chi) ($ sim (1- ($size sim 0))))))
                           (fxe (nm/runfunc fcalls function xe)))
                      (if (< fxe fxr)
                          (setf ($ sim (1- ($size sim 0))) xe
                                ($ fsim (1- ($size fsim 0))) fxe)
                          (setf ($ sim (1- ($size sim 0))) xr
                                ($ fsim (1- ($size fsim 0))) fxr)))
                    (if (< fxr ($ fsim (- ($size fsim 0) 2)))
                        (setf ($ sim (1- ($size sim 0))) xr
                              ($ fsim (1- ($size fsim 0))) fxr)
                        (if (< fxr ($ fsim (1- ($size fsim 0))))
                            (let* ((xc ($sub ($mul (1+ (* psi rho)) xbar)
                                             ($mul (* psi rho) ($ sim (1- ($size sim 0))))))
                                   (fxc (nm/runfunc fcalls function xc)))
                              (if (<= fxc fxr)
                                  (setf ($ sim (1- ($size sim 0))) xc
                                        ($ fsim (1- ($size fsim 0))) fxc)
                                  (setf doshrink 1)))
                            (let* ((xcc ($add ($mul (- 1 psi) xbar)
                                              ($mul psi ($ sim (1- ($size sim 0))))))
                                   (fxcc (nm/runfunc fcalls function xcc)))
                              (if (< fxcc ($ fsim (1- ($size fsim 0))))
                                  (setf ($ sim (1- ($size sim 0))) xcc
                                        ($ fsim (1- ($size fsim 0))) fxcc)
                                  (setf doshrink 1))))))
                (when (= 1 doshrink)
                  (loop :for j :from 1 :to n
                        :do (progn
                              (setf ($ sim j) ($add ($ sim j)
                                                    ($mul sigma ($sub ($ sim j) ($ sim 0)))))
                              (setf ($ fsim j) (nm/runfunc fcalls function ($ sim j))))))
                (let ((sr ($sort fsim)))
                  (setf fsim (car sr)
                        ind (cadr sr)))
                (setf sim (nm/order sim ind))
                (when (and (<= (nm/maxsimdiff sim) xatol) (<= (nm/maxfsimdiff fsim) fatol))
                  (setf keep nil))))
    (let ((x ($ sim 0))
          (fval ($min fsim)))
      (unless (zerop wflag)
        (cond ((= 1 wflag) (prn "[WARN] MAX FUNCTION CALLS EXCEEDED"))
              ((= 2 wflag) (prn "[WARN] MAX ITERATIONS EXCEEDED"))))
      (values x fval))))
