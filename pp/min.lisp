(in-package :th.pp)

(defun nm/runfunc (counter function args)
  (let ((args (if (listp args) args ($list args))))
    (setf ($ counter 0) (1+ ($ counter 0)))
    (apply function args)))

(defun nm/xts (x xts)
  (tensor (loop :for i :from 0 :below ($count xts)
                :for v = ($ x i)
                :for vt = ($ xts i)
                :collect (if (= vt 1) (round v) v))))

(defun nm/maxsimdiff (sim xts)
  (let ((sim0 (nm/xts ($ sim 0) xts)))
    (loop :for k :from 1 :below ($size sim 0)
          :for simk = (nm/xts ($ sim k) xts)
          :maximizing ($max ($abs ($sub simk sim0))))))

(defun nm/maxfsimdiff (fsim) ($max ($abs ($sub fsim ($ fsim 0)))))

(defun nm/convergedp (sim fsim xts xatol fatol)
  (and (<= (nm/maxsimdiff sim xts) xatol) (<= (nm/maxfsimdiff fsim) fatol)))

(defun nm/order (tensor ind)
  (let ((size ($size tensor)))
    ($gather tensor 0 ($expand ($transpose ind) size))))

(defun nm/init! (sim x0 xts zdelt nonzdelt)
  (setf ($ sim 0) x0)
  (loop :for k :from 0 :below ($count x0)
        :for vt = ($ xts k)
        :for y = (tensor x0)
        :do (progn
              (if (zerop ($ y k))
                  (if (= vt 1)
                      (setf ($ y k) 1)
                      (setf ($ y k) zdelt))
                  (if (= vt 1)
                      (setf ($ y k) (if (> (abs (round (* nonzdelt ($ y k)))) 0)
                                        (round (* (+ 1 nonzdelt) ($ y k)))
                                        (+ ($ y k) (* (signum ($ y k)) 1))))
                      (setf ($ y k) (* (+ 1 nonzdelt) ($ y k)))))
              (setf ($ sim (1+ k)) y))))

(defmacro nm/reorder! (sim fsim)
  `(let ((sr ($sort ,fsim))
         (ind nil))
     (setf ,fsim (car sr)
           ind (cadr sr))
     (setf ,sim (nm/order ,sim ind))))

(defun nm/2ndworst (sim) ($ sim (- ($size sim 0) 2)))
(defun nm/worst (sim) ($ sim (1- ($size sim 0))))
(defun (setf nm/worst) (nv sim) (setf ($ sim (1- ($size sim 0))) nv))
(defun nm/xbar (sim)
  ($squeeze ($mean ($subview sim 0 (1- ($size sim 0))) 0)))
(defun nm/xr (sim xts xbar rho)
  (let ((ws (nm/worst sim)))
    (let ((xr ($sub ($mul (1+ rho) xbar) ($mul rho ws))))
      (loop :for i :from 0 :below ($count xts)
            :for vt = ($ xts i)
            :for mv = ($ xbar i)
            :for rv = ($ xr i)
            :for wv = ($ ws i)
            :when (= vt 1)
              :do (if (>= rv wv)
                      (if (= rv wv)
                          (setf ($ xr i) (round ($ xr i)))
                          (if (= (round rv) (round wv))
                              (setf ($ xr i) (1+ (round ($ xr i))))
                              (setf ($ xr i) (round ($ xr i)))))
                      (if (= (round rv) (round wv))
                          (setf ($ xr i) (1- (round ($ xr i))))
                          (setf ($ xr i) (round ($ xr i))))))
      xr)))
(defun nm/xe (sim xts xbar rho chi)
  (let ((ws (nm/worst sim)))
    (let ((xe ($sub ($mul (1+ (* rho chi)) xbar) ($mul (* rho chi) ws))))
      (loop :for i :from 0 :below ($count xts)
            :for vt = ($ xts i)
            :for mv = ($ xbar i)
            :for ev = ($ xe i)
            :for wv = ($ ws i)
            :when (= vt 1)
              :do (if (>= ev wv)
                      (if (= ev wv)
                          (setf ($ xe i) (round ($ xe i)))
                          (if (= (round ev) (round wv))
                              (setf ($ xe i) (1+ (round ($ xe i))))
                              (setf ($ xe i) (round ($ xe i)))))
                      (if (= (round ev) (round wv))
                          (setf ($ xe i) (1- (round ($ xe i))))
                          (setf ($ xe i) (round ($ xe i))))))
      xe)))
(defun nm/xc (sim xts xbar rho psi)
  (let ((ws (nm/worst sim)))
    (let ((xc ($sub ($mul (1+ (* psi rho)) xbar) ($mul (* psi rho) ws))))
      (loop :for i :from 0 :below ($count xts)
            :for vt = ($ xts i)
            :for mv = ($ xbar i)
            :for cv = ($ xc i)
            :for wv = ($ ws i)
            :when (= vt 1)
              :do (if (>= cv wv)
                      (if (= cv wv)
                          (setf ($ xc i) (round ($ xc i)))
                          (if (= (round cv) (round wv))
                              (setf ($ xc i) (1+ (round ($ xc i))))
                              (setf ($ xc i) (round ($ xc i)))))
                      (if (= (round cv) (round wv))
                          (setf ($ xc i) (1- (round ($ xc i))))
                          (setf ($ xc i) (round ($ xc i))))))
      xc)))
(defun nm/xcc (sim xts xbar psi)
  (let ((ws (nm/worst sim)))
    (let ((xcc ($add ($mul (- 1 psi) xbar) ($mul psi ws))))
      (loop :for i :from 0 :below ($count xts)
            :for vt = ($ xts i)
            :for mv = ($ xbar i)
            :for cv = ($ xcc i)
            :for wv = ($ ws i)
            :when (= vt 1)
              :do (if (>= cv wv)
                      (if (= cv wv)
                          (setf ($ xcc i) (round ($ xcc i)))
                          (if (= (round cv) (round wv))
                              (setf ($ xcc i) (1+ (round ($ xcc i))))
                              (setf ($ xcc i) (round ($ xcc i)))))
                      (if (= (round cv) (round wv))
                          (setf ($ xcc i) (1- (round ($ xcc i))))
                          (setf ($ xcc i) (round ($ xcc i))))))
      xcc)))
(defun nm/shrink (xts simj sim0 sigma)
  (let ((nsim ($add simj ($mul sigma ($sub simj sim0)))))
    (loop :for i :from 0 :below ($count xts)
          :for vt = ($ xts i)
          :for nv = ($ nsim i)
          :for ov = ($ simj i)
          :when (= vt 1)
            :do (if (>= nv ov)
                    (if (= nv ov)
                        (setf ($ nsim i) (round ($ nsim i)))
                        (if (= (round nv) (round ov))
                            (setf ($ nsim i) (1+ (round ($ nsim i))))
                            (setf ($ nsim i) (round ($ nsim i)))))
                    (if (= (round nv) (round ov))
                        (setf ($ nsim i) (1- (round ($ nsim i))))
                        (setf ($ nsim i) (round ($ nsim i))))))
    nsim))
(defun nm/shrink! (sim xts fsim fcalls function sigma)
  (let ((n (1- ($size sim 0))))
    (loop :for j :from 1 :to n
          :for sim0 = ($ sim 0)
          :for simj = ($ sim j)
          :do (progn
                (setf ($ sim j) (nm/shrink xts simj sim0 sigma))
                (setf ($ fsim j) (nm/runfunc fcalls function ($ sim j)))))))

(defun nelder-mead (function x0 &key adaptive (xatol 1E-4) (fatol 1E-4))
  (let* ((n ($count x0))
         (maxiter (* n 200))
         (maxfun (* n 200))
         (rho 1.0)
         (chi (if adaptive (+ 1.0 (/ 2.0 n)) 2.0))
         (psi (if adaptive (- 0.75 (/ 1.0 (* 2.0 n))) 0.5))
         (sigma (if adaptive (- 1.0 (/ 1.0 n)) 0.5))
         (nonzdelt 0.05)
         (zdelt 0.00025)
         (sim (tensor (1+ n) n))
         (fsim (tensor (1+ n)))
         (fcalls (tensor.long '(0)))
         (keep T)
         (wflag 0)
         (xts (tensor.long (loop :for k :from 0 :below ($count x0)
                                 :collect (if (integerp ($ x0 k)) 1 0)))))
    (nm/init! sim x0 xts zdelt nonzdelt)
    (loop :for k :from 0 :to ($count x0)
          :do (setf ($ fsim k) (nm/runfunc fcalls function ($ sim k))))
    (nm/reorder! sim fsim)
    (loop :for iterations :from 1
          :while (let ((fw (< ($ fcalls 0) maxfun))
                       (iw (< iterations maxiter)))
                   (cond ((not fw) (setf wflag 1))
                         ((not iw) (setf wflag 2)))
                   (and keep fw iw))
          :for xbar = (nm/xbar sim)
          :for xr = (nm/xr sim xts xbar rho)
          :for fxr = (nm/runfunc fcalls function xr)
          :do (let ((doshrink nil))
                (if (< fxr ($ fsim 0))
                    (let* ((xe (nm/xe sim xts xbar rho chi))
                           (fxe (nm/runfunc fcalls function xe)))
                      (if (< fxe fxr)
                          (setf (nm/worst sim) xe
                                (nm/worst fsim) fxe)
                          (setf (nm/worst sim) xr
                                (nm/worst fsim) fxr)))
                    (if (< fxr (nm/2ndworst fsim))
                        (setf (nm/worst sim) xr
                              (nm/worst fsim) fxr)
                        (if (< fxr (nm/worst fsim))
                            (let* ((xc (nm/xc sim xts xbar rho psi))
                                   (fxc (nm/runfunc fcalls function xc)))
                              (if (<= fxc fxr)
                                  (setf (nm/worst sim) xc
                                        (nm/worst fsim) fxc)
                                  (setf doshrink T)))
                            (let* ((xcc (nm/xcc sim xts xbar psi))
                                   (fxcc (nm/runfunc fcalls function xcc)))
                              (if (< fxcc (nm/worst fsim))
                                  (setf (nm/worst sim) xcc
                                        (nm/worst fsim) fxcc)
                                  (setf doshrink T))))))
                (when doshrink (nm/shrink! sim xts fsim fcalls function sigma))
                (nm/reorder! sim fsim)
                (when (nm/convergedp sim fsim xts xatol fatol) (setf keep nil))))
    (let ((x ($ sim 0))
          (fval ($min fsim)))
      (unless (zerop wflag)
        (cond ((= 1 wflag) (prn "[WARN] MAX FUNCTION CALLS EXCEEDED"))
              ((= 2 wflag) (prn "[WARN] MAX ITERATIONS EXCEEDED"))))
      (values x fval))))
