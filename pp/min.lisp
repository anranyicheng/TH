(in-package :th.pp)

(defun nm/runfunc (counter function args)
  (let ((args (if (listp args) args ($list args))))
    (setf ($ counter 0) (1+ ($ counter 0)))
    (apply function args)))

(defun nm/xts (x xts)
  (tensor (loop :for i :from 0 :below ($count xts)
                :for v = ($ x i)
                :for vt = ($ xts i)
                :collect (if (= vt 1) (round v) v))))

(defun nm/maxsimdiff (sim xts)
  (let ((sim0 (nm/xts ($ sim 0) xts)))
    (loop :for k :from 1 :below ($size sim 0)
          :for simk = (nm/xts ($ sim k) xts)
          :maximizing ($max ($abs ($sub simk sim0))))))

(defun nm/maxfsimdiff (fsim) ($max ($abs ($sub fsim ($ fsim 0)))))

(defun nm/convergedp (sim fsim xts xatol fatol)
  (prn sim (nm/maxsimdiff sim xts))
  (prn fsim (nm/maxfsimdiff fsim))
  (and (<= (nm/maxsimdiff sim xts) xatol) (<= (nm/maxfsimdiff fsim) fatol)))

(defun nm/order (tensor ind)
  (let ((size ($size tensor)))
    ($gather tensor 0 ($expand ($transpose ind) size))))

(defun nm/init! (sim x0 xts zdelt nonzdelt)
  (setf ($ sim 0) x0)
  (loop :for k :from 0 :below ($count x0)
        :for vt = ($ xts k)
        :for y = (tensor x0)
        :do (progn
              (if (zerop ($ y k))
                  (if (= vt 1)
                      (setf ($ y k) 1)
                      (setf ($ y k) zdelt))
                  (if (= vt 1)
                      (setf ($ y k) (if (> (abs (round (* nonzdelt ($ y k)))) 0)
                                        (round (* (+ 1 nonzdelt) ($ y k)))
                                        (+ ($ y k) (* (signum ($ y k)) 1))))
                      (setf ($ y k) (* (+ 1 nonzdelt) ($ y k)))))
              (setf ($ sim (1+ k)) y))))

(defmacro nm/reorder! (sim fsim)
  `(let ((sr ($sort ,fsim))
         (ind nil))
     (setf ,fsim (car sr)
           ind (cadr sr))
     (setf ,sim (nm/order ,sim ind))))

(defun nm/2ndworst (sim) ($ sim (- ($size sim 0) 2)))
(defun nm/worst (sim) ($ sim (1- ($size sim 0))))
(defun (setf nm/worst) (nv sim) (setf ($ sim (1- ($size sim 0))) nv))
(defun nm/xbar (sim)
  ($squeeze ($mean ($subview sim 0 (1- ($size sim 0))) 0)))
(defun nm/xr (sim xbar rho)
  ($sub ($mul (1+ rho) xbar) ($mul rho (nm/worst sim))))
(defun nm/xe (sim xbar rho chi)
  ($sub ($mul (1+ (* rho chi)) xbar) ($mul (* rho chi) (nm/worst sim))))
(defun nm/xc (sim xbar rho psi)
  ($sub ($mul (1+ (* psi rho)) xbar) ($mul (* psi rho) (nm/worst sim))))
(defun nm/xcc (sim xbar psi)
  ($add ($mul (- 1 psi) xbar) ($mul psi (nm/worst sim))))
(defun nm/shrink! (sim fsim fcalls function sigma)
  (let ((n (1- ($size sim 0))))
    (loop :for j :from 1 :to n
          :do (progn
                (setf ($ sim j) ($add ($ sim j)
                                      ($mul sigma ($sub ($ sim j) ($ sim 0)))))
                (setf ($ fsim j) (nm/runfunc fcalls function ($ sim j)))))))

(defun nelder-mead (function x0 &key adaptive (xatol 1E-4) (fatol 1E-4))
  ;; XXX more discrete variable related customizations are required.
  (let* ((n ($count x0))
         (maxiter (* n 200))
         (maxfun (* n 200))
         (rho 1.0)
         (chi (if adaptive (+ 1.0 (/ 2.0 n)) 2.0))
         (psi (if adaptive (- 0.75 (/ 1.0 (* 2.0 n))) 0.5))
         (sigma (if adaptive (- 1.0 (/ 1.0 n)) 0.5))
         (nonzdelt 0.05)
         (zdelt 0.00025)
         (sim (tensor (1+ n) n))
         (fsim (tensor (1+ n)))
         (fcalls (tensor.long '(0)))
         (keep T)
         (wflag 0)
         (xts (tensor.long (loop :for k :from 0 :below ($count x0)
                                 :collect (if (integerp ($ x0 k)) 1 0)))))
    (nm/init! sim x0 xts zdelt nonzdelt)
    (loop :for k :from 0 :to ($count x0)
          :do (setf ($ fsim k) (nm/runfunc fcalls function ($ sim k))))
    (nm/reorder! sim fsim)
    (loop :for iterations :from 1
          :while (let ((fw (< ($ fcalls 0) maxfun))
                       (iw (< iterations maxiter)))
                   (cond ((not fw) (setf wflag 1))
                         ((not iw) (setf wflag 2)))
                   (and keep fw iw))
          :for xbar = (nm/xbar sim)
          :for xr = (nm/xr sim xbar rho)
          :do (let ((fxr (nm/runfunc fcalls function xr))
                    (doshrink nil))
                (if (< fxr ($ fsim 0))
                    (let* ((xe (nm/xe sim xbar rho chi))
                           (fxe (nm/runfunc fcalls function xe)))
                      (if (< fxe fxr)
                          (setf (nm/worst sim) xe
                                (nm/worst fsim) fxe)
                          (setf (nm/worst sim) xr
                                (nm/worst fsim) fxr)))
                    (if (< fxr (nm/2ndworst fsim))
                        (setf (nm/worst sim) xr
                              (nm/worst fsim) fxr)
                        (if (< fxr (nm/worst fsim))
                            (let* ((xc (nm/xc sim xbar rho psi))
                                   (fxc (nm/runfunc fcalls function xc)))
                              (if (<= fxc fxr)
                                  (setf (nm/worst sim) xc
                                        (nm/worst fsim) fxc)
                                  (setf doshrink T)))
                            (let* ((xcc (nm/xcc sim xbar psi))
                                   (fxcc (nm/runfunc fcalls function xcc)))
                              (if (< fxcc (nm/worst fsim))
                                  (setf (nm/worst sim) xcc
                                        (nm/worst fsim) fxcc)
                                  (setf doshrink T))))))
                (when doshrink (nm/shrink! sim fsim fcalls function sigma))
                (nm/reorder! sim fsim)
                (when (nm/convergedp sim fsim xts xatol fatol) (setf keep nil))))
    (let ((x ($ sim 0))
          (fval ($min fsim)))
      (unless (zerop wflag)
        (cond ((= 1 wflag) (prn "[WARN] MAX FUNCTION CALLS EXCEEDED"))
              ((= 2 wflag) (prn "[WARN] MAX ITERATIONS EXCEEDED"))))
      (values x fval))))
