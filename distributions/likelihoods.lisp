(in-package :th.distributions)

(defgeneric beta-support-p (data))
(defmethod beta-support-p ((data number)) (and (< data 1) (> data 0)))
(defmethod beta-support-p ((data tensor))
  (let ((nz ($sum ($le data 0)))
        (no ($sum ($ge data 1))))
    (and (zerop nz) (zerop no))))
(defmethod beta-support-p ((data list))
  (let ((ne (filter (lambda (v) (or (<= v 0) (>= v 1))) data)))
    (zerop ($count ne))))

(defgeneric fdt (data))
(defmethod fdt ((data number)) data)
(defmethod fdt ((data tensor)) data)
(defmethod fdt ((data list)) (tensor data))

(defun $ll/beta (data &optional (a 1) (b 1))
  (when (beta-support-p data)
    (let ((data (fdt data)))
      ($sum ($+ ($mul ($sub a 1) ($log data))
                ($mul ($sub b 1) ($log ($- 1 data)))
                ($neg ($lbetaf a b)))))))

(defgeneric exponential-support-p (data))
(defmethod exponential-support-p ((data number)) (> data 0))
(defmethod exponential-support-p ((data tensor))
  (let ((nz ($sum ($le data 0))))
    (zerop nz)))
(defmethod exponential-support-p ((data list))
  (let ((ne (filter (lambda (v) (<= v 0)) data)))
    (zerop ($count ne))))

(defun $ll/exponential (data &optional (rate 1))
  (when (exponential-support-p data)
    (let ((data (fdt data)))
      ($sum ($sub ($log rate) ($mul rate data))))))

(defgeneric uniform-support-p (data l u))
(defmethod uniform-support-p ((data number) l u) (and (>= data l) (<= data u)))
(defmethod uniform-support-p ((data tensor) l u)
  (let ((nz ($sum ($lt data l)))
        (no ($sum ($gt data u))))
    (and (zerop nz) (zerop no))))
(defmethod uniform-support-p ((data list) l u)
  (let ((ne (filter (lambda (v) (or (< v l) (> v u))) data)))
    (zerop ($count ne))))

(defun $ll/uniform (data &optional (l 0) (u 1))
  (when (and (> u l) (uniform-support-p data l u))
    ($mul ($count data) ($log ($sub u l)))))

(defun $ll/gaussian (data &optional (location 0) (scale 1))
  (when (and (> scale 0))
    (let ((data (fdt data)))
      ($sum ($mul 0.5
                  ($add ($log (* 2 pi))
                        ($add ($mul 2 ($log scale))
                              ($div ($square ($sub data location))
                                    ($square scale)))))))))

(defun $ll/normal (data &optional (location 0) (scale 1)) ($ll/gaussian data location scale))

(defun gamma-support-p (data) (exponential-support-p data))

(defun $ll/gamma (data &optional (shape 1) (scale 1))
  (when (gamma-support-p data)
    (let ((data (fdt data)))
      ($sum ($add ($neg ($add ($log ($gammaf shape)) ($mul shape ($log scale))))
                  ($sub ($mul ($sub shape 1) ($log data))
                        ($div data scale)))))))

(defun $ll/t (data &optional (location 0) (scale 1) (dof 1))
  (when (and (> scale 0) (> dof 0))
    (let ((data (fdt data)))
      ($sum
       ($sub ($sub ($sub ($sub ($sub ($log ($gammaf ($div ($add dof 1) 2)))
                                     ($log ($gammaf ($div dof 2))))
                               ($log scale))
                         ($mul 0.5 ($log pi)))
                   ($mul 0.5 ($log dof)))
             ($mul ($mul 0.5 ($add dof 1))
                   ($log ($add 1 ($div ($square ($div ($sub data location) scale)) dof)))))))))

(defun $ll/chisq (data &optional (k 1)) ($ll/gamma data ($div k 2) 0.5))

(defun $ll/dice (data &optional (n 6))
  (when (and (> n 0) (uniform-support-p data 0.99 6.01))
    (let ((data (fdt data)))
      ($mul ($count data) ($log ($div 1 n))))))

(defgeneric bernoulli-support-p (data))
(defmethod bernoulli-support-p ((data number)) (or (= data 1) (zerop data)))
(defmethod bernoulli-support-p ((data tensor))
  (let ((nz ($sum ($eq data 0)))
        (no ($sum ($eq data 1))))
    (eq ($count data) (+ nz no))))
(defmethod bernoulli-support-p ((data list))
  (let ((ne (filter (lambda (v) (or (zerop v) (= v 1))) data)))
    (eq ($count data) ($count ne))))

(defun $ll/bernoulli (data &optional (p 0.5))
  (when (and (> p 0) (< p 1) (bernoulli-support-p data))
    (let ((data (fdt data)))
      (let ((nd ($count data))
            (nt ($count ($nonzero data))))
        ($add ($mul nt ($log p)) ($mul (- nd nt) ($log ($sub 1 p))))))))

(defun lbc (n k)
  (let ((n1 ($add n 1))
        (k1 ($add k 1))
        (nk1 ($add ($sub n k) 1)))
    ($sub ($lgammaf n1)
          ($add ($lgammaf k1) ($lgammaf nk1)))))

(defun $ll/binomial (data &optional (p 0.5) (n 1))
  (when (and (> p 0) (< p 1) (> n 0) (uniform-support-p data 0 n))
    (let ((data (fdt data)))
      (let ((lp ($log p))
            (lq ($log ($sub 1 p)))
            (k data)
            (nk ($sub n data)))
        ($sum ($add (lbc n data) ($add ($mul k lp) ($mul nk lq))))))))

(defgeneric poisson-support-p (data))
(defmethod poisson-support-p ((data number)) (>= data 0))
(defmethod poisson-support-p ((data tensor))
  (let ((nz ($sum ($lt data 0))))
    (zerop nz)))
(defmethod poisson-support-p ((data list))
  (let ((nz (filter (lambda (v) (< v 0)) data)))
    (zerop ($count nz))))

(defun $ll/poisson (data &optional (rate 1.0))
  (when (and (> rate 0) (poisson-support-p data))
    (let ((data (fdt data)))
      ($sum ($sub ($sub ($mul data ($log rate)) rate)
                  ($lgammaf ($add data 1)))))))
